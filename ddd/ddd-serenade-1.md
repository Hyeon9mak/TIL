# 8월 23일 강의

## OT

> 레거시 프로젝트를 줄 것이고 그걸 개선하는 강의가 될 것

DDD는 추상적이고 철학적, 개발방법론 (프로젝트 방법론)

DDD를 이해를 하려면 비교대상이 필요하다.
그 비교 대상은 보통 어느정도 규모가 있는 실무 프로젝트가 된다.
실무 프로젝트에 대해서 어느정도 고민을 해보고 도메인에 대한 이해가 있는 사람을
대상으로 수업을 진행한다.

DDD는 정답이 있는게 아니다.
"이 도메인에서는 이래.", "저 도메인에서는 저래."
또한 같은 도메인이어도 각 개발 문화마다 적용 결과물이 다를 수 있다.
이것들을 모두 직접 경험해보아야 한다.
요구사항에 적합한 DDD를 찾아내는 것.

### 개발자가 가질 덕목이 어떤 것들이 있을까?

- 대용량, 대량 트래픽
- 제로 투 원, 처음부터 끝까지 개발
- 대규모 리팩터링

### DDD 책 추천

1. DDD START
2. 반 버논 저
3. 에릭 에반스 저

순서로 읽는 걸 추천

### 들어가기 전에

- 경우에 따라 DDD 기술 규칙과 패턴이 DDD 구현에 방해가 될 수 있다.
- 중요한 것은 패턴이 아니다.
    - 패키지를 어떻게 나눈다던지... 그런건 DDD가 아니다.
- 비즈니스 문제에 맞게 코드를 구성하고 동일한 비즈니스 용어(유비쿼터스 언어)를 사용하는 것이다.
- CRUD 서비스 처럼 간단한 업무는 DDD 없이 더 간단한 방법으로 관리할 수 있다.
- 복잡한 도메인일수록 DDD가 빛을 낼 것이고, 반대의 경우 빛이 바랄 것이다.

<br>

## 왜 도메인 주도 설계인가?

### 기존의 개발

앞선 사례가 남의 일처럼 느껴지지 않을 것이다. 개발 과정과 관련된 예를 하나 더 들어보자.

1. 기획자와 심도 있는 논의를 거쳐 기획이 결정된다. (또는 기획자가 일방적으로 결정한다.)
2. 기획서를 보고 데이터베이스 테이블을 설계한다.
3. 데이터베이스 테이블을 기반으로 모델을 만든다.
4. getter와 setter 메서드가 모델에 추가된다.
5. **서비스가 매우 커진다.**

또 하나 더 들어보자.

1. 기획자와 심도 있는 논의를 거쳐 기획이 결정된다. (또는 기획자가 일방적으로 결정한다.)
2. 기획서를 보니 데이터를 중복으로 관리하기보다는 기존 테이블에 새로운 컬럼 몇 개만 추가하면 될 것 같다.
3. 새로운 getter와 setter 메서드가 모델에 추가된다.
4. **서비스가 매우 커진다.**

### 소프트웨어의 존재 가치

소프트웨어의 본질은 해당 소프트웨어의 사용자를 위해 관련 문제를 해결하는 능력에 있다.
아무리 기술적으로 정교하고 뛰어난 성능을 갖추더라도 당면한 문제를 해결하지 못하는 소프트웨어는
실패한 소프트웨어라고 할 수 있다. 얼마나 빠른지, 얼마나 많은 처리가 가능한지, 얼마나 많은 사람이 붙어
사용할 수 있는지는 나중 이야기이다.

WEB + APPLICATION 에서 우리가 집중해야하는 것은 당연히 APPLICATION이다.
APPLICATION이 잘 다듬어지면 WEB, MOBILE, PC 등등 얼마든지 채널 교체가 가능하다.
빠른지, 많은 처리가 가능한지, 동시에 얼마나 감당 가능한지 등은 채널레벨에서 고민하면 된다.
그렇게 분리된다.

소프트웨어를 만들려면 비즈니스를 이해하고, 관련 지식을 쌓고, 본질적 복잡성(essential complexity)과
우발적 복잡성(accidental complexity)을 구별하는 것이 매우 중요하다.

회계 도메인은 어떠한가? 그 자체가 복잡하고 어렵다. 그런 것들을 본질적인 복잡성이라 부른다.
우발적 복잡성은 어떠한가? 솔루션으로 인해 발생하며, 프레임워크, DB, 인프라가 이것에 해당한다.
본질적(APPLICATION) 복잡성이 해결이 되어야지만 우발적(CHANNEL) 복잡성을 해결할 수 있다.

### 클린 아키텍처가 제안하는 보편적인 원칙

- 프레임워크 독립성: 아키텍처는 다양한 기능의 라이브러리를 제공하는 소프트웨어, 즉 프레임워크의 존재 여부에 의존하지 않는다. 이를 통해 이러한 프레임워크를 도구로 사용할 수
  있으며, 프레임워크가 지닌 제약사항 안으로 시스템을 욱여 넣도록 강제하지 않는다.
- 테스트 용이성: 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트할 수 있다.
- UI 독립성: 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다. 예를 들어 업무 규칙을 변경하지 않은 채 웹 UI를 콘솔 UI로 대체할 수 있다.
- 데이터베이스 독립성: 오라클이나 MS SQL 서버를 몽고DB, 빅테이블, 카우치DB 등으로 교체할 수 있다. 업무 규칙은 데이터베이스에 결합되지 않는다.
- 모든 외부 에이전시에 대한 독립성: 실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.

### 도메인

> "소프트웨어는 사람의 욕망과 욕구를 해결하려고 만든 창조물입니다. 사람들의 욕망과 욕구가 개발자에게 전달됐을 때 우리는 그것을 도메인이라고 부릅니다." - 조영호

그렇다면 도메인이란 무엇인가? 도메인이란 한마디로 '소프트웨어로 해결하고자 하는 문제 영역'이다.
같은 엘레베이터를 만들더라도, 어디에 있느냐에 따라 문제가 다를 수 있다.
소프트웨어를 사용하는 사용자의 활동이나 관심사와 관련되어 있다.
소프트웨어 산업은 다른 산업 내에서 발생하는 다양한 비즈니스 문제를 해결한다는 점에서 독특하다.
쇼핑몰을 구축할 때 도메인은 전자 상거래(e-commerce)이며, 사용자가 무엇에 대해 말하고 원하는지 이해하려면
전자 상거래에 대한 지식이 필요하다.

### 도메인 모델

모델이라는 단어에서 우리는 모델 하우스, 플라스틱 모델 등 다양한 것을 생각할 수 있다.
모델은 목적을 위해 현실 세계에 존재하는 것을 가공하고 편집하여 우리에게 정보를 제공한다.
도메인 모델은 특정 다이어그램이 아니라 다이어그램이 전달하려는 **아이디어이자 목적을 가진 의사소통 수단**이다.
이 의사소통 수단은 회의, 기획, 디자인, 개발에 사용되어야 한다.
항공권 예약 시스템에서는 항공기, 승객 등 물리적으로 존재하는 것들을 모델링할 수 있고,
회계 시스템에서는 화폐, 금융 등 물리적으로 존재하지 않는 것들을 모델링할 수 있다.
도메인 모델을 사용하면 여러 이해관계자가 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움이 된다.

### 도메인 주도 설계

현실은 어떤가? 기획자가 생각하는 도메인 모델과 개발자가 생각하는 도메인 모델이 같을까?
개발자는 요구 사항을 기술 언어로 번역하고 솔루션에 집중해 문제를 숨기는 경향이 있다.
번역된 언어는 의사소통을 위해 언어를 다시 번역해야 하고 이 과정에서 많은 의사소통 비용이 낭비된다.

에릭 에반스의 동명의 책에서 유래한 DDD(Domain-Driven Design)는 도메인 모델의 적용 범위를 구현으로 확장하기 위해
도메인을 탐색하고 학습하기 위한 다양한 원칙과 패턴을 제안한다.
(그러나 결코 "설계를 하라, 그 다음에 구축하라"가 아니다. 100% 완벽한 설계란 존재할 수 없다는 전제가 깔려있다.)

> 에릭 에반스는 익스트림 프로그래밍(eXtreme Programming, XP)의 열렬한 지지자이다.
> 익스트림 프로그래밍은 설계와 관련된 의사 결정의 중요성을 인정하면서도 선행 설계에 대해 단호히 반대한다.
> 그 대신 의사소통을 개선하고 프로젝트 방향을 빠르게 변경할 수 있는 능력을 향상시키는 데 큰 노력을 기울인다.

### 세 개의 기둥

- 유비쿼터스 언어
- 전략적 설계
- 전술적 설계

### 확장 가능성은 어디까지?

확장 가능성이 뛰어나야한다는 말에 공감하는가? 그런 경우 확장 가능성을 어디까지 봐야하는가?
이럴 땐 업계 선두주자를 보면 좋다!

<br>

## 기타 팁
@FuntionalInterface에 추상 메서드가 1개를 초과할 경우
람다를 쓸 수 없고 익명 클래스를 만들어서 사용해야만 한다.

```java

@FunctionalInterface
public interface MoveStrategy {

    boolean isMovable();
}


    // 익명 클래스
    @Override
    public boolean movable() {
        // 구현
    }
```

이런 경우 가짜 객체를 만들어서 사용하면 좋다.

```java
public class ForwardStrategy implements MoveStrategy {

    @Override
    public boolean isMovable() {
        return true;
    }
}

public class StopStrategy implements MoveStrategy {

    @Override
    public boolean isMovable() {
        return false;
    }
}
```
