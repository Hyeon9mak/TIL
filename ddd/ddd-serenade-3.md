# 9월 20일 강의

## 이벤트스토밍 워크샵 정리
- 퍼실리테이터는 팀원이 아닐수록 좋다.
- 퍼실리테이터가 도메인에 관심을 갖고 이해하려고 드는 순간 진행이 멈춘다.
    - 퍼실리데이터 역할을 맡는다면, 도메인을 그 자리에서 이해하려하기보단, 영상을 녹화해두고 진행에 집중하는게 더 좋은 방향일 것.
- 오프라인에서 진행하는 경우 포스트잇에 누가 쓴 내용인지 기록이 되지만, 온라인에서는 Miro 같은 툴로 색깔로 구분을 해놓고, 이벤트별로 나중에 한꺼번에 색상 전환
- 각각의 컨텍스트는 각각의 MSA가 될 수 있다.
    - 모놀리식 관점으로 해석하면 각각의 컨텍스트는 각각의 `Service`가 될 수 있다.
    - 나중에 이 서비스를 기준으로 팀을 나눌 수도 있다.

<img width="1057" alt="image" src="https://user-images.githubusercontent.com/37354145/191240894-98a5dd59-8305-48d9-a7aa-b21218c3960c.png">

- 각각 내부에서도 작은 도메인을 갖게 된다.
- 도메인이라고 부르는 것은 쉽게 말해서 솔루션을 제공해야할 문제의 영역이다.
- 컨텍스트는 문제를 해결하기 위한 솔루션에 해당되는 영역이다.
- 여러가지 컨텍스트 중에 가장 집중해야할 영역을 고민해야한다.
    - 현재 예시의 경우 `주문`이 가장 중요한 영역일 것이다.
    - '핵심 도메인'이라고도 부른다.
    - 시니어, 핵심 멤버들이 `주문`과 같은 영역에 배치된다.
    - 그 외 서브 도메인, 하위 도메인에도 개발자가 배치된다.
    - 범용, 일반 하위 도메인은 굳이 우리 비즈니스가 아니더라도 어디서든 다 필요한 도메인
    - 일반 하위 도메인은 외부 서비스나 외주(혹은 외부 API)를 맡기는 것으로 충분히 해결할 수 있다.
    - 여기에 개발 인력을 투자하는 것보다 비용을 내는게 훨씬 저렴하기 때문

<br>

## 모델링

Q. 요구사항과 모델링의 차이는 무엇인가요?  
A. 요구사항은 사용자 관점. 사용자 스토리.
모델링은 실제 해당 요구사항을 충족할 수 있는 동작을(역할을) 수행할 수 있는 도메인 모델을 정리하는 것.
프로젝트를 진행하는 모든 관계자들이 같은 이해를 할 수 있도록 정하는게 도메인 모델.

<img width="1099" alt="image" src="https://user-images.githubusercontent.com/37354145/191244062-0c851526-c722-484b-9b01-d485536e7564.png">

support.dex.org 사이트의 메뉴 화면 구성이다.
메뉴를 살펴보면 무언가 보이지 않는가? 바로 바운디드 컨텍스트다.
계정 관련 업무를 찾고 싶다면 `ACCOUNT BASICS`, 결제 관련 업무를 찾고 싶다면 `PAYMENTS & REFUNDS`를 살펴보면 될 것이다.
이와 같이 주변에서도 바운디드 컨텍스트를 쉽게 접할 수 있다.

Q. 모델링은 꼭 글로만 작성해야하나요?  
A. 모델링을 꼭 글로만 표현할 필요는 없다. 모델링을 그림으로 표현하면 더욱 자세하고 풍성한 모델링이 될 것이다.
모델링을 진행할 때 "이 요구사항과 모델링을 보고 모든 개발자가 유사한(동일한 기능을 수행하는) 코드를 작성할 수 있을까?"를 고민하면 매우 좋다.

<br>

## 전술적 설계 - ENTITY 와 VALUE OBJECT

DDD를 관통하는 개념은 분할 정복이다. 소프트웨어를 한 눈에 살펴보기 힘드니 나오는 것이 컨텍스트 맵이고,
각 맵을 통해 나눠진 컨텍스트로 하나씩 해결해나가는.. 그래서 DDD 와 Agile이 잘 어울리기도 하다.

### ENTITY와 VALUE OBJECT

- 도출한 모델은 크게 ENTITY와 VALUE OBJECT로 구분
- 데이터와 함께 도메인 기능을 제공한다.

![image](https://user-images.githubusercontent.com/37354145/191248239-79a9a83f-81ae-4b59-9b8e-f6b02f62bf53.png)

### VALUE OBJECT

- 밸류 타입은 불변
- 의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용
- 시스템이 성숙함에 따라 데이터 값을 객체로 대체
- 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.
- 정말 String으로 우편 번호를 표현할 수 있는가?
- 항상 equals() 메서드를 오버라이드할 것을 권고한다.

> equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java

### 불변 객체
- 모든 클래스를 상태를 변경할 수 없는 불변 클래스(immutable class)로 만들면 유지 보수성이 크게 향상된다.
- 불변 객체에는 아래의 ‘식별자 변경(identity mutability)’ 문제가 발생하지 않는다.
- 객체가 완전하고 견고한 상태이거나 아니면 아예 실패하는 실패 원자성(failure atomicity)을 가진다.
    - 가변 객체를 사용하면 `@Transactional` 과 같은 프레임워크의 힘을 빌리지 않고 롤백하는 코드를 일일히 수동으로 작성해줘야한다.
- 시간적 결합(temporal coupling)을 없앨 수 있다.
    - 언제 호출하느냐에 따라 값이 달라지는...
- 스레드 안정성
    - 객체가 여러 스레드에서 동시에(concurrently) 사용될 수 있고 예측 가능한(predictable) 결과를 보장하는 객체의 품질
    - 여러 스레드에서 동시 사용 가능하다는 건 웹 애플리케이션 레벨에서는 '여러 레이어에서 사용할 수 있다'로 볼 수도 있다.
    - 불변이라는 특성 때문에 레이어 간 데이터 이동이 가능한 것.
    - 그러나 여전히 VO 와 DTO는 엄연히 다르다.
        - VO는 DTO가 될 수 있지만, DTO는 VO가 될 수 없다.
    - DTO의 필드로 VO를 사용할 수 있는가? 사용할 수 있다. 단, 컨버터를 만들어서 사용해라.
        - 그게 귀찮다면 VO를 풀어서 DTO에 넣을 것.
- 단순성(simplicity), 객체가 더 단순해질 수록 응집도는 더 높아지고, 유지보수는 더 쉬워진다.
    - 불변 객체를 유지하기 위해서는 프로퍼티(필드) 개수가 필연적으로 적어질 수 밖에 없다. (점점 나뉘게 된다.)
- 불변 객체의 크기가 작은 이유는 불변 객체의 경우 생성자 안에서만 상태를 초기화할 수 있기 때문이다.

### ENTITY
- 값(필드)이 변화해도 추적하기 위한 수단.
- 절대 변하지 않는 식별자를 갖는다.
- 객체의 상태 중 해당 객체의 고유한 성질을 표현할 수 있는 상태들을 식별자라고 부른다.
- 식별자는 ENTITY 객체마다 고유해서 각 ENTITY는 서로 다른 식별자를 갖는다.

```
식별자 생성
- 특정 규칙에 따라 생성
- UUID 사용
- 값을 직접 입력
- 일련번호 사용(시퀀스나 DB의 자동 증가 칼럼 사용)
```

특정 대상을 VO로 봐야하는가 ENTITY로 봐야하는가?
정답은 컨텍스트에 따라 다르다.

- 돈(Money)는 VO인가 ENTITY인가?
- 민간인 기준 VO
- 조폐공사 기준 ENTITY

### 도메인 모델에 set 메서드 넣지 않기
- 도메인 모델에 getter 메서드와 setter 메서드를 무조건 추가하는 것은 좋지 않은 버릇
- 특히 setter 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- setter 메서드의 또 다른 문제는 도메인 객체를 생성할 때 완전한 상태가 아닐 수도 있다는 것이다.
- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야 한다.

```java
changeShippingInfo() vs setShippingInfo()
completePayment() vs setOrderState()
```

<br>

## 전술적 설계 - AGGREGATE와 REPOSITORY

무수히 많이 생겨난 VO와 ENTITY를 어떻게 관리할 것인가?
컨텍스트는 단위가 너무 크고, VO와 ENTITY는 단위가 너무 작다.
그 사이에서 분할정복을 도와주는 논리적 개념이 AGGREGATE 다.

### AGGREGATE

- 관련 객체를 하나로 묶은 군집
- 애그리거트는 군집에 속한 객체들을 관리하는 ROOT ENTITY를 갖는다.
- 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
    - 때문에 ID를 이용한 간접 참조를 적극 활용한다.
- 두 개 이상의 ENTITY로 구성되는 애그리거트는 드물게 존재한다.

![image](https://user-images.githubusercontent.com/37354145/191252563-4efd49e7-cf0d-4121-90e3-47d801a9dd47.png)

개발자 관점이 아닌 비즈니스나 외부 시스템 관점으로 보았을 때, Order AGGREGATE 에서는 Order를 가지고 소통한다.
하나의 AGGREGATE 에서 Root는 무조건 1개다. 2개 이상일 수 없다.
Root 가 가지는 식별자는 외부에서 바라보는 식별자이므로 글로벌 식별자라고 부른다.
자식 ENTITY와 같은, Root가 아닌 ENTITY가 가지는 식별자는 무조건 ROOT를 통해서 접근 후 찾아보므로 로컬 식별자라고 부른다.

Q. 자식 ENTITY를 주로 다루는 환경에서는 자식 ENTITY가 ROOT가 될 수 있을까?  
A. 당연하다. 똑같은 ENTITY가 컨텍스트 별로 ROOT가 될수도, CHILD가 될 수도 있다.

Q. 하나의 DB 테이블을 구성해둔 뒤, 컨텍스트별로 ENTITY를 다르게 만들어서 관리할 수 있나?  
A. 그렇게 관리하지 않는다. 결국 DB 테이블을 분리한다. 컨텍스트를 나누게 되면 데이터 중복이 무조건 발생하게 된다.
그러나 중복을 감수하고서라도 복잡도를 낮추는게 훨씬 더 큰 가치일 것이다.

Q. CHILD ENTITY라고 생각해서 다른 ENTITY의 하위로 밀어넣고 하나의 어그리거트로 묶었는데, 차인드 ENTITY 데이터만 따로 내려주는 등의 요구사항이 생긴다면 어그리거트를 잘못 묶은걸까요? 혹은 바운디드 컨텍스트를 잘못 나눈걸까요?  
A. CHILD ENTITY가 분리되어야 하는 시점이라는 뜻. 물론 단순 조회용이라면 CQRS를 구성하는게 더 낫다. 그렇지 않은 경우 CHILD ENTITY가 별개의 AGGREGATE로 분리될 시점인 것.

Q. AGGREGATE 별로 각각의 VO를 가져야 하나요?  
A. 개발 환경별로 다르다. 완전히 동일하다면 동일한 VO로 추출할 수도 있겠고, 각각의 비즈니스 로직을 가진다면 각각 가져갈 수 있겠다.

Q. AGGREGATE 당 ENTITY를 1개씩 구성하는게 정상인가요?  
A. AGGREGATE의 규모를 어떻게 가져가느냐에 따라 다르다. 다음 수업에 관련 이야기를 할 것.

Q. 라이프사이클?  
A. 라이프사이클은 객체가 물리적으로 생성되는 시점을 이야기하는게 아니라, 객체끼리 논리적인 행위(개념)에 대한 일관성을 지키는 것을 의미한다.
예를 들자면 장바구니와 장바구니 속 물건은 물리적으로 생성되는 시점이 다르다. 그러나 장비구나의 총 금액과 장바구니 속 물건들의 가격의 합은 일치해야 한다는
제약사항이 존재한다. 이런 것은 같은 라이프사이클을 갖는다고 본다.



### AGGREGATE ROOT

- 애그리거트 ROOT의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
    - 비즈니스 규칙을 지키기 위한 (일관성을 지키기 위한) 단위.
    - DB ACID 원칙과 굉장히 유사하게 느껴진다.
    - 때문에 Bounded Context와 AGGREGATE 는 엄연히 다른 개념이 되는 것이다.
- 애그리거트 ROOT는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.
- ROOT ENTITY는 애그리거트에 속해 있는 ENTITY와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.

![image](https://user-images.githubusercontent.com/37354145/191252899-5281f410-e823-43c7-b07f-d9fff42c75c2.png)

### AGGREGATE 참조

- 외부에서는 AGGREGATE 내부에 어떤 VO가 있는지, 어떻게 구성되어있는지는 알 수도, 알 필요도 없다.
    - 무조건 AGGREGATE ROOT를 통해서만.
- 애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다.
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다,
- ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다.
    - 특히나 테스트 코드를 작성할 때 given 절을 위해 테스트 대상이 아닌 불필요한 연관관계 엔티티를 만들어내고... 하는 일련의 과정이 생략된다.

### REPOSITORY

AGGREGATE의 일관성을 지켜주기 위한 도우미 패턴.

- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델
- 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.
- 리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 - 도중에 `NullPointerException`과 같은 문제가 발생하게 된다.
- 리포지토리는 애그리거트(루트) 단위로 존재하며 테이블(엔티티) 단위로 존재하는 것이 아니다.
- Repository 개념은 기본적으로 DDD 에서 왔다.
    - 다만 DAO(Data Access Object)로도 사용할 수 있다.
    - 그러나 엄연히 다른 개념임은 사실이다.
- 그래서 Repository가 인프라가 아닌 도메인 패키지에 위치할 수 있게 된다.

```java
public interface OrderRepository {
    public Order findByNumber(OrderNumber number);
    public void save(Order order);
    public void delete(Order order);
}
```

> SpringDataJdbc는 DDD의 영향을 굉장히 많이 받아서, Lazy Loading 자체를 지원하지 않는다.

<br>

## 전술적 설계 - SERVICE

> Micro Service, Domain Service, Service... 너무나 많은 Service가 세상에 존재한다.
> 여기서 이야기하는건 Domain Service

### 여러 애그리거트가 필요한 기능

결제 금액 계산 로직

- 상품 애그리거트: 구매하는 상품의 가격이 필요하다. 또한 상품에 따라 배송비가 추가되기도 한다.
- 주문 애그리거트: 상품별로 구매 개수가 필요하다.
- 할인 쿠폰 애그리거트: 쿠폰별로 지정한 할인 금액이나 비율에 따라 주문 총 금액을 할인한다. 할인 쿠폰을 조건에 따라 중복 사용할 수 있다거나 지정한 카테고리의 상품에만 적용할 수 있다는 제약 조건이 있다면 할인 계산이 복잡해진다.
- 회원 애그리거트: 회원 등급에 따라 추가 할인이 가능하다.

- 이 상황에서 실제 결제 금액을 계산해야 하는 주체는 어떤 애그리거트일까?
- 한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다.

### 도메인 서비스

- 응용 영역의 서비스가 용용 로직을 다룬다면, 도메인 서비스는 도메인 로직을 다룬다.
- 도메인 영역의 애그리거트나 밸류와 같은 다른 구성요소와 비교할 때 다른 점은 **상태 없이 로직만 구현**한다.
- 도메인 서비스를 사용하는 주체는 애그리거트가 될 수도 있고, 응용 서비스가 될 수도 있다.
- 애그리거트 메서드를 실행할 때 도메인 서비스를 인자로 전달하지 않고 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하기도 한다.
    - 도메인 서비스의 메서드에 애그리거트를 인자로 넣어줄수도, 애그리거트 속 메서드에 도메인 서비스를 인자로 넣어줄 수도 있다.
- 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 검사해 보면 된다.
- 여러 애그리거트를 사용할 떄만 도메인 서비스를 사용하는 것이 아니다. 도메인 서비스는 도메인 계층의 방파제다.
    - 도메인 지식이 애플리케이션 계층을 침범하는 걸 막아주는 역할이다.
    - 금액을 계산해야한다는 명확한 비즈니스 목적을 가졌을 경우, 응용 서비스에서 이런 비즈니스 로직을 묶는 것이 아니라, 도메인 서비스를 만들어서 이를 관리할 것.
- 도메인 서비스를 잘 활용할수록 도메인에 대한 변경이나 반영이 그대로 코드에도 반영이 될 것이다.
    - 유지보수성이 굉장히 뛰어나진다.

Q. 도메인 서비스를 흐린 눈으로 보면 하나의 도메인으로 보이는거 같기도 한데, 이렇게 봐도 될까요?  
A. YES. 단 상태가 없음을 분명히 기억할 것.

Q. 서로 다른 애그리거트의 데이터를 모아서 조회해주어야 하는데...  
A. 전제 조건은 Command 성 요청인지, 조회성 요청인지를 확실하게 구별해야한다. 조회만을 위해서 필요하고 Command 를 위해서는 필요하지 않다면
QueryDSL을 통해 조합해서 반환하는 등의 방식도 고민할 수 있다. Command 성 요청에서 사용하지 않는다면 꼭 같이 묶어 둘 필요가 없다.

### FACTORY

- 어떤 객체를 생성하는 일이 복잡하다면 FACTORY를 이용해 이것을 캡슐화할 수 있다.
    - 생성자, 팩토리 클래스
    - `환불` 정보를 만들기 위해 우선 존재하는 `결제`
    - 꼭 서비스를 사용하지 않더라도, `결제` 객체 내부에서 `환불` 인스턴스를 생성하면 어떨까?
    - `결제`의 ID 등을 곧바로 조합해서 사용할 수 있을 것이다.
- 연관된 애그리거트에서 생성해 보자.
- 어떤 다른 곳에서 해당 객체를 생성할 때 생산자의 정보를 필요로 하는 것을 줄일 수 있다.
- 아울러 생산자와 생성된 객체 사이의 특별한 관계를 전해주기도 합니다.
