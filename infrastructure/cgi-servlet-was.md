## CGI의 탄생 - 동적인 콘텐츠에 대한 요구
정적 콘텐츠는 웹 클라이언트의 요청에 웹서버가 미리 준비된 HTML로 응답하는 것이다.
동적 콘텐츠는 웹 클라이언트의 요청에 웹 서버가 HTML파일을 직접 생성해서 응답하는 것이다.

동적 콘텐츠를 생성해서 웹 클라이언트에 보내려면 웹 서버와 콘텐츠를 생성하는 프로그램의 연동이 필요하다. 그래서 고안된 것이 
CGI(Common Gateway Interface)다. CGI에서는 웹 서버가 클라이언트로부터 받은 요청을 웹 서버상에서 작동하는 프로그램에게 보낸다.
프로그램은 요청을 참조해서 HTML을 생성한 후 웹 서버에게 돌려보내준다. 웹 서버는 프로그램으로부터 받은 HTML을 마치 정적 콘텐츠였던 것처럼 돌려주는 것이다.
(즉, CGI는 웹 서버와 프로그램 사이에 존재한다.) 이 때 동작하는 프로그램 구현에 Perl, PHP, C언어가 활약했다.

CGI를 이용하자 동적 콘텐츠를 생성할 뿐만 아니라 웹 브라우저에서 입력을 받아 그에 상승ㅇ하는 처리를 하는 애플리케이션을 제작할 수 있게 됐다. 
이 때 검색 사이트, 게시판, 인터넷 쇼핑 같은 편리한 기능을 제공하는 사이트들이 등장했다. 이것이 웹 애플리케이션의 시작이다.

<br>

## 서블릿의 등장 - CGI의 문제점
CGI를 이용한 웹 애플리케이션이 보급됨에 따라 새로운 문제가 발생했다.

웹 애플리케이션에 요구되는 기능의 규모가 커지고 복잡해지면서 Perl, PHP 등으로 객체지향 프로그래밍을 지원하지 않았기 때문에 대규모 프로그램을 제작하기도, 유지보수 하기도 어려웠다.
또한 웹 브라우저에서 요청이 도착할 때마다 CGI가 프로그램의 프로세스를 가동했는데, 이 때 발생하는 부하가 수 많은 요청을 따라잡지 못해서 성능에 관련된 불만이 폭주했다.

이 때 등장한 것이 썬 마이크로시스템즈의 제임스 고슬링이 개발한 자바(Java)였다. 객체지향을 완벽히 지원해서 대규모 시스템을 개발하기 용이하고, 
당시 널리 사용되던 C와 문법이 매우 비슷해서 C언어 개발자들이 쉽게 받아들일 수도 있었따. 또 멀티 스레드와 보안, 네트워크 통신 등 기술을 표준화된 방식으로 지원한다는 점이 매력이었다.

자바 자체는 웹 애플리케이션을 위해 탄생한 언어가 아니었지만, 웹 애플리케이션이 당시 기업의 시스템 개발에서도 주류가 되고 있었기 때문에 JavaEE(Java Enterprise Edition)이 등장했고, 
그 일부로서 서블릿(Servlet)이 등장했다.

서블릿은 자바로 만들어진, HTML등의 웹 콘텐츠를 생성하기 위한 프로그램이다. 기본적으로 CGI와 같은 개념이지만, 콘텐츠를 생성하는 언어가 자바이며 객체지향을 지원함으로써 대규모 애플리케이션 개발에 적합하다는 것과 
운영체제나 하드웨어에 의존하지 않고 작동한다는(JVM) 자바의 장점을 그대로 이어 받은 점(서블릿도 다양한 플랫폼 상에서 작동한다), 웹 서버와 같은 프로세스 속에서 콘텐츠를 생성하는 프로그램(스레드)이 작동하기 때문에 
(CGI에서는 웹 서버가 요청을 보내면 Perl/C 언어 프로그램이 생성) 비교적 빠른 속도를 가진다는 장점이 있다.

그러나 웹 서버만 설치하는 경우에 비해 설치가 어렵고, 객체지향 관련 지식이 필요하다는 점이 단점이 되겠다.

<br>

## JSP의 탄생 - 서블릿의 문제점
```java
public class Calc extends HttpServlet {
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 콘텐츠 유형 설정
        response.setContentType("text/html;charset=UTF-8");
        // HTML 출력 준비
        PrintWriter out = response.getWriter();

        // HTML 출력
        out.println("<html><head>");
        out.println("<title>Calcurator</title>");
        out.println("</head><body>");
        out.println("<p>1000원의 부가가치세 포함 가격 = " + (1000 * 1.1) + "원</p>");
        out.println("</body></html>");

        // HTML 출력 완료 처리
        out.flush();
        out.close();
    }
}
```

`out.println` 이라는 명령의 괄호 안에 HTML로 출력할 문자열을 지정한다.
화면의 디자인을 변경할 때마다 프로그램을 변경해야해서 작업 효율이 나쁘며, 서블릿을 통해 출력되는 HTML을 예측하기 어렵다는 문제점을 갖고 있다.
또한 개발에 대해 잘 모르는 웹 디자이너가 프로그램을 잘못 건드릴 문제도 존재했다.

이런 문제점을 개선하기 위해 고안된 것이 JSP(Java Server Pages)라는 기술이다. JSP와 서블릿의 차이를 이해하고자 먼저 JSP를 사용해 앞의 서블릿을 바꾸면

```jsp
<html>
<head>
<title>Calcurator</title>
</head>
<body>
<p>1000원의 부가가치세 포함 가격 = <% out.println(1000 * 1.1); %>원</p>
</body>
</html>
```

위와 같은 코드로 표현할 수 있다. HTML에 거의 근접한 형태로 알기 쉽고, 웹 디자이너도 큰 어려움 없이 사용할 수 있어서 분업이 확실해졌다.

<br>

## 웹 애플리케이션 프레임워크의 시대 - 서블릿과 JSP의 문제점
서브릿과 JSP 덕분에 간단한 웹 애플리케이션을 만들기가 매우 편해졌다. 그러나 웹 애플리케이션의 규모가 커지면 여전히 어렵다. 
대규모 애플리케이션을 처음부터 서블릿과 JSP로 만들면 코딩 분량이 엄청나며, 완성되기까지 막대한 시간과 돈이 든다. 

또한 시스템의 규모가 커지면서 개발에 관여하는 사람이 늘고, 이들이 독자적인 라이브러리나 클래스를 만든 후 결합하려고 했을 때 
결합이 되지 않거나 디자인 팀과 개발 팀의 성과물을 ㅇ녀결하는 과정에서 불협화음이 일어나는 문제가 잦았다. 

그래서 재사용이라는 발상을 떠올려서, 재사용할 수 있는 부분을 늘려서 애플리케이션 개발을 용이하게 하는 프레임워크가 등장했다. (스프링의 등장)

<br>

## 서블릿과 JSP는 누가 구동시키는가? - 애플리케이션 서버
정확한 계층 구조는 아래와 같다.

```
--------------------        --------------------
                                서블릿/JSP
                      --->  --------------------
    웹 서버 (아파치)             애플리케이션 서버 (톰캣)
                      <---  --------------------
                                    JVM
--------------------        --------------------
```

CGI는 웹 서버가 C/Perl로 작성한 프로그램을 매번 실행시키는 것으로 연동됐다. 
그렇다면 애플리케이션 서버는 어떻게 웹 서버와 연동될까? 대표적인 웹 애플리케이션의 구성인 아파치 HTTP서버와 톰캣의 조합을 예로 설명한다.

즉 웹 서버 내부에서, 아파치가 우선적으로 클라이언트의 HTTP요청을 톰캣(애플리케이션 서버)으로 전송하고, 톰캣이 웹 애플리케이션에 전달한다.
그렇다면 이렇게 분리했을 때 얻는 이점은 무엇인가?
HTML파일이나 이미지, 동영상등 정적인 콘텐츠를 웹 서버(아파치) 쪽에 배치하고, 동적인 컨텐츠들만 애플리케이션 서버(톰캣) 쪽에 담당시키는 식으로 분담이 가능해진다.
즉, 서버 쪽에 프로세스가 2개 구동되는 것이다.

그렇다면 서버는 어떻게 애플리케이션 서버로까지 전송해야할 URL(동적 자원을 요청하는)을 구분할 수 있을까? 
컴퓨터가 이를 자동으로 구분할 수 없어, 우리가 규칙을 지정해준다. (workers.properties, httpd.conf 파일 등)

애플리케이션 서버와 웹 서버를 분리시켜 놓으면, 애플리케이션 서버를 다른 별도의 환경에서 동작시킬 수도 있다. 
웹 클라이언트가 웹 서버와 HTTP 프로토콜로 통신하는 것과 같이 웹 서버와 애플리케이션 서버가 ajp13 프로토콜을 통해 
통신을 주고 받는 것이다.

그러나 이 경우 적어도 컴퓨터가 두 대 이상 필요하기 때문에 시스템의 규모가 커질 수 밖에 없다. 이런 단점을 메꿀만큼의 이점은 무엇일까?

웹 서버와 애플리케이션 서버의 작업량을 비교하면 일반적으로 애플리케이션 서버의 작업량이 훨씬 많다. 
웹 서버는 HTTP 요청에 지정된 파일을 웹 브라우저에 되돌려주기만 하면 되는데 비해 
애플리케이션 서버에선 웹 애플리케이션이 온갖 복잡한 작업을 처리하기 때문이다.
한편 웹 서버는 요청 하나하나에 대한 처리량이 적은 대신 접수하는 HTTP 요청의 수가 매우 많은 경향이 있다. 
현대의 웹 사이트에서는 페이지 하나를 표시하는 데만도 페이지의 내용을 기술한 HTML 파일 외에 디자인 정보를 기술한 
CSS파일과 JS파일, 각종 이미지와 플래시 파일 등 다양한 정적 콘텐츠가 필요하다. 이 때문에 수많은 HTTP 요청을 처리해야 한다.

그래서 웹 서버와 애플리케이션 서버를 서로 다른 컴퓨터에 배치하면 처리량이 가볍지만 횟수가 많은 정적 콘텐츠는 웹 서버, 
횟수는 적지만 처리량이 무거운 동적 콘텐츠에 대한 요청은 애플리케이션 서버와 같은 식으로 성격의 요청을 적절히 분담할 수 있으며, 
하나의 웹 서버에 여러 대의 애플리케이션(톰켓) 서버를 물려서 동적 컨텐츠 요청을 처리할 수도 있다!

최근 웹 서버의 기능을 가진 애플리케이션 서버도 등장하고 있다. 굳이 아파치와 같은 웹 서버를 연동하지 않아도 단독으로 
웹 서버를 작동시킬 수 있다.(톰캣이 이를 지원한다.)
