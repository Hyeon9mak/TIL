# JPA를 사용하는 이유

> 김영한 님의 **자바 ORM 표준 JPA 프로그래밍**을 읽고 인상적인 파트를 정리한 내용

## JPA 또한 데이터베이스 성능과 관련된 이슈가 많은데 굳이 JPA를 사용하는 이유가 무엇인가? 
데이터베이스 성능과 관련된 이슈는 말 그대로 데이터베이스 이슈다. 
JPA의 문제라기보다는 SQL을 직접 사용해도 발생하는 문제들이다.
JPA를 사용해서 얻는 가장 큰 성과는 객체 중심의 개발로 인한 유지보수성 향상 및 
테스트 작성 용이성 증가다.

<br>

## JPA 대신 자바 직렬화/역직렬화는 어떤가?
직렬화된 객체를 검색하기 어렵다는 문제가 있어서 현실성이 떨어진다.

<br>

## SQL 중심 개발은 참조 관계를 표현할 때 문제가 자주 발생한다.
```java
class Member {

    private Long id;
    private String name;
    private Team team; // 새로 추가된 필드
}

class Team { 
    
    private Long id;
    private String name;
}
```

기존에 `Member`에게 `Team` 필드가 없던 상태에서, 갑작스럽게 두 객체가 관계를 맺게 되었다.
위와 같은 객체 참조관계가 존재할 때, SQL을 통해 이를 어떻게 표현할 것인가?
기존 `memberDao.findMemberById()`를 수행할 때 `Team` 정보도 함께 포함할 것인가?
아니면 `memberDao.findMemberWithTeamById()` 이라는 새로운 조회 메서드를 만들 것인가?

한 사람이 개발하는 것이라면 문제가 없겠지만, 여러 사람이 개발하는 경우 `memberDao.findMemberById()` 
메서드명 만으로는 `Team`을 함께 조회하는지 안하는지 알 수 없다. 직접 Dao 내부의 쿼리를 뜯어보아야 한다.

요약하자면 다음과 같다.

- 진정한 의미의 계층 분할이 어렵다. (SQL, JDBC API가 엔티티와 강한 의존관계를 갖는다.)
- 엔티티를 신뢰 할 수 없다. (직접 Dao의 쿼리를 확인해야 한다.)
    - 레이어드 아키텍쳐에서는 이전 레이어에서 넘어온 객체를 신뢰할 수 있어야한다.
    - 그러나 이 경우 Database 레이어에서 넘어온 엔티티를 Service 레이어가 신뢰할 수 없는 상황이 된다.
- SQL에 의존적인 개발을 피하기 어렵다.

<br>

## 객체 그래프 탐색 또한 어렵다.
```java
public void process() {
    Member member = memberDao.findMemberById(id);
    member.getTeam(); // member 조회시 team도 가져오나?
    member.getOrder().getDelivery(); // 이것들은? 가져오나?
}
```

`memberDao.findMemberById()`를 통해서 객체 그래프가 어디까지 그러졌는지 알 수 없다. 
엔티티를 신뢰할 수 없기 때문에 객체 그래프 탐색 또한 섣불리 할 수 없다.

JPA는? 객체 그래프를 미리 그리지 않는다. 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다. (지연로딩) 
이 때문에 엔티티를 신뢰하고 자유롭게 객체 그래프를 탐색 할 수 있다.
**(JPA의 지연로딩은 객체 그래프 탐색을 현실성 있게 해결하는 개념!!)**

<br>

## 결국은...
- 데이터베이스 테이블에 맞춘 DTO 스러운 엔티티를 만들기 시작한다.
    - 객체지향은 유지보수를 위해 등장한 개념.
    - 객체지향에서 멀어지기 때문에 덩달아 유지보수가 어려워진다.
- 객체를 객체답게 사용하려할 수록 매핑 작업만 늘어난다.
    - 데이터베이스 테이블에 맞추기 위해서 이상한 메서드를 많이 만들게 된다.
- 악순환의 반복

<br>

## JPA(ORM)의 등장
과거 자바 진영엔 엔터프라이즈 자바 빈즈(EJB) 기술이 있었는데 너무 복잡하고 성숙도가 떨어졌고, 자바 엔터프라이즈(J2EE) 애플리케이션 서버에서만 동작했다. 그 때 하이버네이트(hibernate.org) 오픈소스 ORM이 등장했는데, 가볍고 실용적인 데다 기술 성숙도도 높았다. 또 자바 엔터프라이즈 애플리케이션 서버 없이도 동작해서 많은 개발자가 사용했고, 결국 EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준을 만들었는데 이것이 바로 JPA다.

쉽게 이야기해서 JPA는 인터페이스를 모아둔 것이고, JPA를 사용하려면 JPA를 구현한 프레임워크를 선택해야 한다. 
대부분의 경우 하이버네이트를 사용한다.

JPA는 추상화된 데이터 접근 계층을 제공하기 때문에 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다.
대표적으로 로컬 개발 환경은 H2, 상용 환경은 오라클이나 MySQL 같은 데이터베이스를 각각 구성할 수 있는게 모두 데이터 접근 계층 추상화 덕분이다.

<br>

## JPA는 애플리케이션과 JDBC 사이에서 동작
JPA도 마법을 부리는건 아니다. 결국 Java 애플리케이션과 JdbcAPI 사이에서 동작한다.

![image](https://user-images.githubusercontent.com/37354145/144693071-6b73b526-4925-4032-877e-d3ba14af4e70.png)

<br>

## 그래서 JPA를 왜 사용해야 하는가?
### SQL 중심적인 개발에서 객체 중심으로 개발

### 생산성
CRUD, 그 중에서도 Update가 굉장히 쉽다.
JPA를 쓴다는 것은 사상 자체가 컬렉션에 객체를 저장하고 관리한다는 느낌이기 때문에,
별도로 데이터베이스 관련 동작을 시도하지 않고 객체 정보만 수정해도 Update가 반영된다.

### 유지보수
```java
public class Member {
    private Long id;
    private String name;
    private String tel;
}
```
`tel` 필드를 갑작스럽게 추가하게 되더라도, (데이터베이스 컬럼이 자유롭게 변경 가능하다는 가정하에) 
데이터베이스 쪽을 신경쓰지 않아도 된다. SQL은 알아서 JPA가 처리해준다.

### 패러다임의 불일치 해결
1. JPA와 상속
    - 상속관계의 저장에 대해서, JPA가 알아서 각각의 테이블에 맞춰 분리해서 저장해준다.
    - 상속관계의 조회에 대해서, JPA가 알아서 각각의 테이블을 JOIN해서 불러와준다.
2. JPA와 연관관계
    - 객체로 연관관계를 매핑하고, 하나의 엔티티만 저장해도 알아서 둘이 모두 저장된다.
3. JPA와 객체 그래프 탐색
    - getter를 통한 객체간 조회가 가능해진다.
    - 여기서 레이어간의 엔티티를 신뢰하고 사용할 수 있게 된다.
        - 실제 조회가 되지 않았더라도, 지연로딩 개념을 통해서 조회하는 시점에 필요한 엔티티의 내용을 퍼올린다.
4. JPA와 비교하기
    - 동일한 트랜잭션 내에서 조회한 엔티티가 서로 같음을 보장한다.
    - 이부분은 추후 equals, hashCode 오버라이딩으로 동등성을 지켜주는 것으로 자동해결되는 부분이기도 하다.

### 성능
1. 1차 캐시와 동일성 보장
    - 같은 엔티티를 계속 조회하게 된다면, 데이터베이스 커넥션 없이 1차 캐시 공간에 저장해둔 엔티티를 계속 조회할 수 있게 된다.
    - 이 덕분에 데이터베이스 격리 레벨이 `Read Commit`이어도 애플리케이션 레벨에서 `Repeatable Read`가 가능하다.
2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
    - 트랜잭션을 커밋할 때까지 INSERT SQL을 한 공간에 모아둔다.
    - JDBC BATCH SQL 기능을 사용해서 모아둔 SQL을 한 번에 전송한다.
        - JDBC BATCH 기능을 직접 사용하면 코드가 다소 지저분해진다.
        - 근데 JPA는 이걸 알아서 해준다!
    - UPDATE, DELETE로 인한 락(Lock)시간 최소화
        - 트랜잭션 시작부터 커밋 직전까지의 비즈니스 로직 수행 시간동안 ROW에 락이 발생하지 않는다.
        - 트랜잭션 커밋 단계에서만 락이 진행되고, 곧바로 끝난다.
3. 지연 로딩(Lazy Loading)
    - 즉시로딩: JOIN SQL로 한 번에 연관된 객체까지 미리 조회
    - 지연로딩: 객체가 실제 사용될 때 로딩
    - 이걸 옵션 하나 설정으로 바꾼다는게 정말 큰 이점이다.
        - SQL을 직접 작성하는 입장에서는 비즈니스 로직이 바뀔 때마다 쿼리를 튜닝 해야하는게 큰 리소스다.

### 그 외 
- 데이터 접근 추상화와 벤더 독립성
- 표준

<br>

## JPA도 만능은 아님
통계 쿼리처럼 매우 복잡한 SQL의 경우 JPA의 주 관리 범주에서 벗어난다. JPA는 실시간 처리용 쿼리에 최적화 되어 있다. 
정말 복잡한 통계 쿼리는 SQL을 직접 사용하거나 JdbcTemplate과 같은 프레임워크를 혼용하는 것도 좋은 방법이다.
