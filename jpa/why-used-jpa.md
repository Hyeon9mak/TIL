# JPA를 사용하는 이유

> 김영한 님의 **자바 ORM 표준 JPA 프로그래밍**을 읽고 인상적인 파트를 정리한 내용

## JPA 또한 데이터베이스 성능과 관련된 이슈가 많은데 굳이 JPA를 사용하는 이유가 무엇인가? 
데이터베이스 성능과 관련된 이슈는 말 그대로 데이터베이스 이슈다. 
JPA의 문제라기보다는 SQL을 직접 사용해도 발생하는 문제들이다.
JPA를 사용해서 얻는 가장 큰 성과는 객체 중심의 개발로 인한 유지보수성 향상 및 
테스트 작성 용이성 증가다.

<br>

## JPA 대신 자바 직렬화/역직렬화는 어떤가?
직렬화된 객체를 검색하기 어렵다는 문제가 있어서 현실성이 떨어진다.

<br>

## SQL 중심 개발은 참조 관계를 표현할 때 문제가 자주 발생한다.
```java
class Member {

    private Long id;
    private String name;
    private Team team; // 새로 추가된 필드
}

class Team { 
    
    private Long id;
    private String name;
}
```

기존에 `Member`에게 `Team` 필드가 없던 상태에서, 갑작스럽게 두 객체가 관계를 맺게 되었다.
위와 같은 객체 참조관계가 존재할 때, SQL을 통해 이를 어떻게 표현할 것인가?
기존 `memberDao.findMemberById()`를 수행할 때 `Team` 정보도 함께 포함할 것인가?
아니면 `memberDao.findMemberWithTeamById()` 이라는 새로운 조회 메서드를 만들 것인가?

한 사람이 개발하는 것이라면 문제가 없겠지만, 여러 사람이 개발하는 경우 `memberDao.findMemberById()` 
메서드명 만으로는 `Team`을 함께 조회하는지 안하는지 알 수 없다. 직접 Dao 내부의 쿼리를 뜯어보아야 한다.

요약하자면 다음과 같다.

- 진정한 의미의 계층 분할이 어렵다. (SQL, JDBC API가 엔티티와 강한 의존관계를 갖는다.)
- 엔티티를 신뢰 할 수 없다. (직접 Dao의 쿼리를 확인해야 한다.)
- SQL에 의존적인 개발을 피하기 어렵다.

<br>

## 객체 그래프 탐색 또한 어렵다.
```java
public void process() {
    Member member = memberDao.findMemberById(id);
    member.getTeam(); // member 조회시 team도 가져오나?
    member.getOrder().getDelivery(); // 이것들은? 가져오나?
}
```

`memberDao.findMemberById()`를 통해서 객체 그래프가 어디까지 그러졌는지 알 수 없다. 
엔티티를 신뢰할 수 없기 때문에 객체 그래프 탐색 또한 섣불리 할 수 없다.

JPA는? 객체 그래프를 미리 그리지 않는다. 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다. (지연로딩) 
이 때문에 엔티티를 신뢰하고 자유롭게 객체 그래프를 탐색 할 수 있다.
**(JPA의 지연로딩은 객체 그래프 탐색을 현실성 있게 해결하는 개념!!)**

<br>

## JPA의 등장
과거 자바 진영엔 엔터프라이즈 자바 빈즈(EJB) 기술이 있었는데 너무 복잡하고 성숙도가 떨어졌고, 자바 엔터프라이즈(J2EE) 애플리케이션 서버에서만 동작했다. 그 때 하이버네이트(hibernate.org) 오픈소스 ORM이 등장했는데, 가볍고 실용적인 데다 기술 성숙도도 높았다. 또 자바 엔터프라이즈 애플리케이션 서버 없이도 동작해서 많은 개발자가 사용했고, 결국 EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준을 만들었는데 이것이 바로 JPA다.

쉽게 이야기해서 JPA는 인터페이스를 모아둔 것이고, JPA를 사용하려면 JPA를 구현한 프레임워크를 선택해야 한다. 
대부분의 경우 하이버네이트를 사용한다.

JPA는 추상화된 데이터 접근 계층을 제공하기 때문에 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다.
대표적으로 로컬 개발 환경은 H2, 상용 환경은 오라클이나 MySQL 같은 데이터베이스를 각각 구성할 수 있는게 모두 데이터 접근 계층 추상화 덕분이다.

<br>

## JPA도 만능은 아님
통계 쿼리처럼 매우 복잡한 SQL의 경우 JPA의 주 관리 범주에서 벗어난다. JPA는 실시간 처리용 쿼리에 최적화 되어 있다. 
정말 복잡한 통계 쿼리는 SQL을 직접 사용하거나 JdbcTemplate과 같은 프레임워크를 혼용하는 것도 좋은 방법이다.
