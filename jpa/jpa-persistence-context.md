# JPA 영속성 컨텍스트

## JPA에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기 (정적)
- 영속성 컨텍스트 (동적)
    - "엔티티를 영구 저장하는 환경" 이라는 뜻
    - 논리적인 개념 (눈에 보이지 않는다.)
    - 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.

<br>

## 엔티티 매니저 팩토리와 엔티티 매니저
엔티티 매니저는 가상의 데이터베이스로 생각하면 편하다. 대부분의 JPA 기능을 엔티티 매니저가 제공한다.
엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간 공유가 괜찮지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생한다.

엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.
엔티티 매니저 하나당 (하나가 동작할 때) 커넥션을 하나씩 얻는다고 이해하면 될듯.

커넥션은 누가 만드는가?(누가 개수를 통제하는가?) 엔티티 매니저 팩토리. (근데 데이터베이스 자체에서도 통제할거 같긴 함.)

<br>

## 영속성 컨텍스트란?
직역하면 '엔티티를 영구 저장하는 환경' 이라는 뜻이지만, 데이터베이스에 커밋하기 전 임시로 엔티티를 관리하는 환경이라고 생각하는게 좋겠다.

영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다. 즉, 데이터베이스 당 1개가 아니라 엔티티 매니저 당 1개씩 생성될 수 있다.
여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수도 있다.

<br>

## 엔티티의 생명주기
엔티티에는 4가지 상태가 존재한다.

### 비영속(new/transient)
엔티티 객체를 막 생성한 상태. 아직 ID가 부여되지 않았다는 특징이 있다. 영속성 컨텍스트나 데이터베이스와 전혀 관계가 없는 상태.
식별자 값이 있을 수도, 없을 수도 있다.

### 영속(managed)
엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태. ID가 부여되었고 영속성 컨텍스트에 의해 관리된다. 영속성 컨텍스트가 제공하는 
모든 옵션에 영향을 받는다.

### 준영속(deleted)
`em.detach()`로 엔티티 하나를 영속성 컨텍스트에서 배제하거나, `em.close()`로 영속성 컨텍스트가 닫히거나, `em.clear()`로 영속성 컨텍스트를 초기화하면 영속성 컨텍스트에 포함되어 있던 모든 엔티티가 준영속 상태가 된다.
이 때 준영속 상태가 된다고 해서 데이터베이스에도 영향을 받는 것은 아니다. 영속성 컨텍스트와 관계만 끊긴다.

거의 비영속 상태와 비슷하지만 준영속 상태는 한 번 영속화가 진행된 것이므로 식별자 값이 무조건 존재한다.

### 삭제(removed)
엔티티를 데이터베이스와 영속성 컨텍스트 모두에서 삭제한다. 준영속과 삭제는 엄연히 다르다. 삭제는 DB에서 제거 된 것. 준영속은 컨텍스트와 관계가 끝난 것.

<br>

## 영속성 컨텍스트의 장점
### 1차 캐시
영속화 된 엔티티들을 모두 Map 형태의 1차 캐시에 저장한다. KEY는 `@Id`로 매핑한 식별자고, 값은 엔티티 인스턴스가 된다.
`em.find()` 등의 조회가 호출되면 우선 1차 캐시를 조회한다.
1차 캐시에 엔티티가 없는 경우에서야 데이터베이스를 조회한다.
(그리고 데이터베이스 조회에 성공하면 조회 결과를 1차 캐시에 저장한다.)
DB간 데이터통신이 줄어드므로 성능개선이 클.... 것 같지만!
실제로 성능 개선 효과가 크진 않다.(!!!)

대부분의 서비스에서 비즈니스 로직 단위로 트랜잭션을 설정하는데,
트랜잭션이 종료되면 영속성 컨텍스트가 제거된다.
즉, 1차 캐시도 함께 사라지게 되는 것이므로
하나의 트랜잭션 속에서만 성능 개선 효과가 존재하는 것이라
큰 효과를 기대하긴 어렵다.
비즈니스 로직이 굉장히 복잡한 경우에만 이점을 볼 수 있다.

> (모든 트랜잭션 간 공유하는 캐시는 JPA(Hibernate)에서 2차 캐시라 부른다.)

1차 캐시가 주는 장점은 성능적인 것보다는
코드를 조금 더 객체지향적으로 작성 가능하다는 컨셉적인 부분에서 장점이 생긴다.

### 동일성 보장
1차 캐시에서 값으로 엔티티 인스턴스를 저장한다고 했다. `em.find()` 메서드를 통해 엔티티를 조회할 때 항상 같은 인스턴스를 반환하므로 
자동으로 엔티티의 동일성을 보장하게 된다.

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // true
```

이를 통해 Repeatable read 등급의 트랜잭션 격리 수준을
데이터베이스에 영향 받지 않고 애플리케이션 레벨에서 제공할 수 있다.

### 트랜잭션을 지원하는 쓰기 지연
![image](https://user-images.githubusercontent.com/37354145/144773759-af44f8cf-7a89-4198-86bb-d1e8e497a73c.png)

영속성 컨텍스트에는 1차 캐시뿐만 아니라 쓰기 지연 SQL 저장소가 존재한다.
트랜잭션의 시작부터 마지막까지 SQL 저장소에 영속화된 정보들을 기록하고, 트랜잭션의 커밋이 일어나는 순간에 
SQL 저장소에 기록된 내용을 데이터베이스에 동기화(flush)한다.

```java
transaction.begin();

em.persist(memberA);
em.persist(memberB);
// 여기까지 데이터베이스에 INSERT SQL을 보내지 않는다.

transaction.commit();
// 커밋하는 순간 INSERT SQL이 전송된다. (flush)
```

데이터베이스로 동기화가 완료된 후 데이터베이스에서 실제 트랜잭션을 커밋해서 데이터베이스에 등록이 완료된다.
데이터베이스의 트랜잭션 커밋 직전에만 SQL을 전달하면 된다는 트랜잭션의 특성을 이용한 방법이다.

그럼 쓰기 지연을 통해 얻는 이점은 무엇일까?
'버퍼링'(JDBC Batch)이라는 기능을 쓸 수 있게 된다.
트랜잭션 커밋 이전 `em.persist`마다 쿼리가 날아가면, 쿼리를 최적화 할 수 있는 여지 자체가 없다.
그러나 쓰기 지연을 사용하는 경우 `hibernate.jdbc.batch_size` 옵션을 통해 
데이터베이스에 쿼리를 묶어서 한 번에 전송할 수 있게 된다.

> 사실 실시간 서비스를 운영하는 환경에서는 큰 이점을 얻을 기회가 많지 않지만,
어쨌거나 옵션 하나로 쿼리 최적화가 가능하다는 점 자체가 굉장한 부분이다.
실제로 쿼리를 묶어서 보내는 행위를 수동으로 구현하려면 코드가 굉장히 복잡해진다.

### 변경 감지
![image](https://user-images.githubusercontent.com/37354145/144775567-4ca6d4a8-07d4-4975-bfbf-7eb0f51b4850.png)

1차 캐시에는 단순히 KEY, VALUE만 존재하지 않고 엔티티의 변화를 감지하는 스냅샷이 존재한다. 영속성 컨텍스트의 트랜잭션 커밋이 발생할 때 
영속성 컨텍스트 1차 캐시의 VALUE(엔티티 인스턴스)와 스냅샷을 비교하여 변화가 감지되면 데이터베이스에 동기화를 진행한다.
변경 감지는 영속성 컨텍스트가 관리하는(트랜잭션에 포함된) 영속 상태의 엔티티만 효과를 누린다.

JPA의 기본 전략은 필드마다의 변경이 있건 없건 상관없이 모든 필드의 변경을 반영한다.
이렇게 하는 이유 중 가장 큰 이유는 수정 쿼리를 미리 생성해두고 재사용이 가능하다는 점, 한 번 파싱된 쿼리를 재사용 가능하다는 점 때문이다.

엔티티의 필드가 너무 많은 경우 동적 쿼리를 사용하도록 할 수 있으나, JPA 표준은 아니고 Hibernate가 제공하는 기능이다.

```java
@Entity
@org.hibernate.annotations.DynamicUpdate
public class Member {...}
```

상황에 따라 다르지만 컬럼이 대략 30개 이상이면 동적 쿼리가 조금 더 나은 성능을 보인다. 그러나 컬럼이 30개가 될 정도면 테이블 설계가 잘못 되었을 가능성이 높다.

엔티티가 삭제되는 경우(`em.remove(entity)`)에도 트랜잭션의 커밋 단계에서 flush가 호출되면 실제 데이터베이스에 삭제 쿼리를 전달한다.
`em.remove(entity)`의 경우 호출이 되는 순간 즉시 영속성 컨텍스트에서 제거 된다. 때문에 삭제된 엔티티는 재사용하지 말고 자연스럽게 GC의 대상이 되도록 두는 것이 좋다.

### 지연로딩
추후에 조금 더 자세히 다룰 것

<br>

## 플러시(flush)
플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 
이 때 영속성 컨텍스트 1차 캐시에 보관된 엔티티를 지운다고 오해하면 안된다.
영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것 뿐이다!

플러시가 발생하면 어떤 일이 생길까?

- 변경 감지
    - 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스로 전송

영속성 컨텍스트를 플러시하는 방법은 크게 3가지가 있다.

### 1. 직접 호출
`em.flush()` 메서드를 직접 호출한다. 
테스트나 다른 프레임워크를 사용할 때를 제외하고 거의 사용되지 않는다.

### 2. 트랜잭션 커밋 시 자동 호출
JPA가 트랜잭션을 커밋할 때 플러시를 자동으로 호출해준다.

### 3. JPQL 쿼리 실행 시 플러시 자동 호출
```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

query = em.createQuery("SELECT m FROM Member m", Member.class);
List<Member> members = query.getResultList();
```

`memberA`, `memberB`, `memberC`는 영속성 컨텍스트에만 등록 되었을 뿐, 아직 데이터베이스에 존재하지 않는다.
그러나 JPQL을 통해서 엔티티를 조회하는 경우 어떻게 해야할까? 아직 엔티티들이 데이터베이스에 등록되지 않았으므로 조회되지 않는다. 
JPA는 이런 문제를 예방하기 위해 JPQL을 실행할 때 플러시를 먼저 자동으로 호출한다.
따라서 위의 결과에서는 `memberA`, `memberB`, `memberC` 엔티티들이 조회된다.

> 식별자를 기준으로 조회하는 `find()` 메서드를 호출할 땐 플러시가 실행되지 않는다고 한다. `em.findById()`를 의미하는 건가? 정확히 어떤 걸 이야기하는지 알아봐야 할 듯.

### 플러시 모드 옵션
```java
// 커밋이나, JPQL이 실행될 때. 기본 옵션
em.setFlushMode(FlushModeType.AUTO)

// 커밋시에만.
em.setFlushMode(FlushModeType.COMMIT)
```

거의 건드릴 일이 없다. 그러나 JPQL을 사용할 때 완전 별개의 테이블을 
조회하는 등의 로직이 있는 경우, flush를 굳이 동기화할 필요가 없기 때문에 
이러한 상황 등에서만 한정적으로 `FlushModeType.COMMIT`을 사용할 수도 있다.

<br>

## 준영속 상태
- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)되는 것
    - `em.detach(entity)`: 특정 엔티티만 준영속화
    - `em.clear()`: 영속성 컨텍스트 초기화
    - `em.close()`: 영속성 컨텍스트 종료
- 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

<br>

## 병합(merge)
`em.merge(entity)`를 통해 준영속, 비영속 상태의 엔티티를 다시 영속 상태로 바꾼다. 이 때 `em.merge(entity)` 메서드는 파라미터로 삽입한 엔티티와 별개의 완전히 새로운 엔티티를 반환한다. 즉, 정확히 이야기하면 엔티티가 준영속 상태에서 영속상태로 변경된다기보다, 새로운 영속 상태의 엔티티가 반환된다.

병합은 준영속, 비영속을 신경쓰지 않는다. 
영속성 컨텍스트에 병합하려는 엔티티가 없으면 데이터베이스를 조회하고, 
데이터베이스에도 없으면 새로운 엔티티를 생성해서 병합을 진행한다.
따라서 병합은 save or update 기능을 수행한다고 볼 수 있다.
