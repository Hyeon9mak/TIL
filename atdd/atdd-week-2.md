## 미션 피드백
> 강의 앞부분 (약 15분 분량) 확인해보기

### `@DirtiesContext`
- 효과적인 테스트 수행을 위해 스프링에서는 context caching 기능 지원
- context caching의 조건이 빈이 오염(변경)되지 않은 경우
- `@DirtiesContext` 를 활용하여 (빈을 오염시켜) 캐시 기능을 사용하지 않게
설정 가능
- 매번 Context를 새로 구성하다보니 시간이 많이 걸림

> 내부에서 어떤 방식으로 컨텍스트를 더럽히고, 어떤 방식으로 싱글톤을 무너뜨려서 재생성을 만들까?
> "오 일부러 bean 객체의 설정을 바꿔서 싱글톤이 불가능하도록? 인스턴스를 다시 만들도록? 하는걸까요?"

### `@SQL 혹은 쿼리 수행`

- 테스트가 수행될 때 마다 테이블들을 truncate 시키는 쿼리 수행
- 컨텍스트를 다시 띄우는 것 보다 낮은 비용
- 테이블이 추가될 때 마다 해당 쿼리 수정이 필요

> 결국 인지범위 관리가 문제다.

### `코드 상으로 테이블 truncate`

- JPA 사용시 EntityManager를 이용하여 테이블 이름 조회
- 아닌 경우 DataSource를 이용하여 테이블 이름 조회
- 각 테이블을 truncate 시켜주는 쿼리 수행
- 테이블 상태에 의존하지 않는 초기화 환경 구축 가능

> 가장 현실적이고 편리한 방법.

<br>
## 인수 테스트 리팩터링

> 아무리 구조화가 잘되고 잘 짜인 테스트 코드라고 하더라도, 가독성이 떨어지고 관리가 지속적으로 이루어지지 못한다면 결국 테스트의 본질을 잃어버리게 된다.

"내가 이 테스트를 봤을 때 이것이 무엇을 검증하는 테스트인지 한 눈에 파악이 되는가?"

![](https://i.imgur.com/vYsLsS4.png)

- 가독성이 좋지 않으면 방치되는 테스트가 될 가능성이 높다
	- `@Ignore` or `@Disabled` 처리가 되어버린다.
- 변경 사항에 대해서 수정하기 어렵다. -> 방치될 가능성 높다
	- `@Ignore` or `@Disabled` 처리가 되어버린다.
- 가독성이 좋으면 해당 기능의 스펙을 나타낼 수 있다.

결국 프로덕션 코드의 가독성이 중요한 만큼 테스트 코드의 가독성도 중요함

## 테스트 코드 중복 제거

> 이 부분 강의내용 또 놓침 ㅡㅡ;;

### 의도 드러내기
- 의미를 잘 드러내기 위해 메서드 래핑하기
![](https://i.imgur.com/u2zsybh.png)


## 모든 요구사항을 인수 테스트로?

![](https://i.imgur.com/qjdnRMp.png)

- 최종적으로 기능이 잘 동작하는가? 를 인수 테스트로
- 예외 케이스는 단위 테스트로
	- 이 과정에서 자연스럽게 책임별로 객체가 분리되기 때문에, 객체지향(SRP)이 지켜질 수 있다.
	- "테스트를 쉽게 만들기 위해 노력하다보면 자연스럽게 객체지향이 지켜진다."

## 단위 테스트 (ATDD + TDD)

- 협력 객체에 따른 구분
- 우리가 말하는 '단위'는 어디까지일까? 어떻게 정의할 수 있을까?
- 결론은 모두가 생각하는 범위와 정의가 다르다.
- 굳이 정리하자면...
	- 작은 코드 조각(단위) 검증
	- 빠르게 수행 가능
	- 격리된 방식으로 처리


![](https://i.imgur.com/qSjdAa8.png)

- 전자는 Station 하나에 대한 테스트
- 후자는 Line + Station 두 개에 대한 복합적인 테스트

![](https://i.imgur.com/Y4Vm6HT.png)

협력 객체가 있는 테스트는 작성이 어렵다. 어떻게 하면 편리하게 할 수 있을까...

![](https://i.imgur.com/cxM2nCw.png)
![](https://i.imgur.com/dK62TE3.png)

- 의존 객체를 직접 구현하는 통합 테스트
- 의존 객체는 구현하지 않고 가짜 객체를 이용해 진행하는 고립 테스트
- 편리한 테스트 작성(고립 테스트 작성)을 위해선 꼭 Mocking 을 해야하는걸까?

## Test Double
![](https://i.imgur.com/zv1KQua.png)

> 테스트 더블이 더블인 이유: 스턴트 배우들을 스턴트 더블이라 부른다고함 ㄷㄷ

### Stub
- 항상 약속된 데이터를 응답하는 객체
- 흔히 `Mockito`, `MockitoExtension`, `@MockBean` 를 활용해서 만들 수 있다.

![](https://i.imgur.com/osqIxGF.png)
![](https://i.imgur.com/UfgOLP3.png)

### Fake
- 인터페이스를 토대로 새로운 구현체를 만들어서 동작을 내가 임의로 지정하는 것.

![](https://i.imgur.com/Q8ZZUst.png)

### Mock

- Stub 과 헷갈릴 수 있는데,
	- Stub 은 협력객체의 응답을 지정하고 테스트 대상 객체의 결과물을 확인한다.
	- Mock 은 테스트 대상 객체의 행위가 호출될 때 협력 객체의 동작이 호출되었는가를 확인한다.
- Mockito 라이브러리를 쓰면

![](https://i.imgur.com/X6qHhRr.png)

## 그래서 어떤 테스트를 짤 것인가?
![](https://i.imgur.com/SnRG7Kr.png)
![](https://i.imgur.com/qogeAVN.png)

- 실제 객체를 통해 테스트하는게 당연히 안정감이 높다.
- 그러나 외부 API 호출, DB 연결을 통한 테스트 속도 증대 등으로 test double 이 필요할 수도 있다.
- 결국 둘다 활용할 줄 알아야함 ㅎㅎ

## 테스트를 바라보는 두 관점

![](https://i.imgur.com/WJ3Dl9u.png)

![](https://i.imgur.com/ypWaqJ2.png)
![](https://i.imgur.com/T7tQY9E.png)

## DBB 의 등장
- 2006년 Dan North 가 TDD 의 진화형으로 처음 소개
- 사용자 관점에서 애플리케이션의 동작에 초점을 맞추는 프로세스
- 행동에 기반하여 TDD 를 수행하자!
- Mockist 와 유사한 방식으로 TDD 진행

> 도메인부터 하나씩 테스트를 작성해나가는 방식이 어려운 사용자들에게 Outside-in 방식으로 접근

## Inside-out vs Outside-in


- 도메인에 필요한 것이 무엇인지 결정
- 도메인 객체가 필요한 작업을 수행
- 이후 작업이 완료되면 그 위에 UI 를 계층화(혹은 상위 계층)


그럼 어떤 방향을 선택하는게 좋을까? 각각 장단이 있는데?

![](https://i.imgur.com/FXRUWiB.png)
![](https://i.imgur.com/cb7qQfc.png)

> DatabaseCleanup 이라는 구현체 내용 관련 소개가 있었다. 강의 다시 보면서 이 부분 체득하면 좋을듯!
> 라이브 템플릿도 미리 만들어두기...