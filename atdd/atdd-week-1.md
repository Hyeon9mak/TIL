##  TDD

![](https://i.imgur.com/AHP8URs.png)

- 우리에게 흔한 TDD 사이클
- TDD 사이클을 지키는 것도 사실 쉽지 않은데, Spring 까지 더해진다면 어떨까?
	- 혹은 콘솔 애플리케이션에서는 지키기 쉽지만, Spring 환경에서라면 어떨까?
	- 복잡한 의존성 관리, 통합의 어려움
- 그 힘든 TDD 를 해내면 성공일까?
	- TDD 를 했으나 기능이 잘 동작하지 않는 경우
	- TDD 를 했으나 최초 의도한대로 기능 개발이 안 된 경우
	- 검증을 위한 테스트가 아닌 방법을 위한 테스트를 작성하게 되고...
	- 그럴 때 `인수 테스트` 를 이용해보면 어떨까?

> 내가 검증하고 싶은 내용이 프레임워크의 동작인지, 도메인(정책)적인 내용인지 확실히 구분지어서 하는 것도 중요하겠다.

## ATDD

![](https://i.imgur.com/iU5nQpV.png)

- E2E(API) 테스트 기반의 인수테스트를 작성을 해보자.
- 인수 테스트 기반의 TDD => ATDD

## 인수 테스트

- 사용자 스토리를 검증하는 기능 테스트
- 사용자 스토리로 테스트할 시나리오를 지정
- 명세나 계약의 요구사항이 충족되는지 확인하는 테스트
- 작업을 마무리 해도 되는지 검증하는 테스트
	- 이 테스트가 성공하면 작업 끝!

![](https://i.imgur.com/EXgfN4X.png)

## 요구사항이 전달 되면 뭐 부터 할까?

![](https://i.imgur.com/qHKB8md.png)

- 지라티켓 만들기
- 요구사항 정의, 요구사항 분석...
- 그러나 이 모든 과정은 서로 다른 결과물을 만들어내기 쉽다.
	- 입/출력 결과물이 다르다던지...
- 그래서 시나리오를 하나 만들어본다. 시나리오를 가미해서 요구사항을 다시 정리한다.

![](https://i.imgur.com/CmY5q7X.png)

- 요구사항을 얼마나 명확히 이해해야하는지에 대한 부담이 사라진다.
- 자연스럽게 도메인 설계, 단위 테스트 작성등을 고민하게 된다.
- 딱 봐도, 어떻게 뭘 구현해야할지가 명확하게 보이는 것이 바로 시나리오
	- 당연히 비정상적인 시나리오도 같이 정의를 해야한다 ㅎㅎ

![](https://i.imgur.com/4L8Fqn0.png)
![](https://i.imgur.com/mreCIrm.png)

단위 테스트, 통합 테스트, E2E 테스트, API 테스트 모두 인수 테스트가 될 수 있다.

> https://hyeon9mak.github.io/acceptance-test-vs-e2e-test/

![](https://i.imgur.com/bjUwOev.png)

## 인수 테스트는 블랙 박스 테스트
- 내부 동작이 어떻게 되는지 알지도, 의존하지도 않는 방식으로 테스트 작성
- 인수 테스트는 블랙 박스 테스트 성질을 가지고 있다.
- 클라이언트는 결과물 내부 구현이나 사용된 기술 기반 검증보다는, 표면적으로 확인할 수 있는 요소를 바탕으로 검증
- 실제 사용하는 상황의 시나리오를 바타으로 요구사항 작성

## E2E 테스트
- (백엔드 서버 기준) API 레벨의 블랙박스 테스트
- 요청과 응답 기준으로 API 레벨의 E2E 테스트


request  에 대한 log 를 찍을 땐 given() 뒤에 .log().all() 을 찍고
response  에 대한 log 를 찍을 땐 then() 뒤에 .log().all 을 찍으면 된다.

> .all() 말고도 여러가지 옵션이 많으니 확인해보자.


RestAssured 는 기본적으로 8080 포트로 요청을 보낸다.
그런데 우리는 테스트에서 RANDOM_PORT 옵션을 사용했다.
그렇다면 어떻게 텍스트를 성공시킬 수 있을까?
RestAssured 의 포트를 수동으로 변경시켜주면 된다.

![](https://i.imgur.com/JWsMd3x.png)

제대로 동작하지 않는데 성공하면 안된다. 그러면 테스트 코드가 잘못 작성된거다.

intellij 자동 코드 생성 기능을 활용하자


mockMVC 를 사용하면 안되는가?
- 사용해도 됨. 취향의 차이일뿐.
- 수업 과정에서는 인수 테스트에만 집중하도록 하기 위해서..
	- MVC 는 MVC 프레임워크에 대한 별개 이해가 필요하기 때문에
- webEnvironment 의 MOCK 설정은 톰캣 대신 MOCK 웹서버를 띄우는 것
	- 이 정보를 가지고 spring 자체적으로 방향을 정핵서 해당 메서드에 안착하게끔 하는 것.
	- 실제로 우리가 개발할 땐 차이를 느끼기 쉽지 않은데, 자체적인 mocking 된 환경을 구성한다.
	- 체감할 수 있는 차이라면 RestAssured 에다가 ~~ 한다면, Mock 도는 스레드랑 실제 웹 서버 테스특 가 도는 스레드가 다르다. 그래서 트랜잭션을 붙여보면 트랜잭션이 동작하지 않는다.
		- 왜? 스레드가 달라서 각자의 스레드에서 돌기 떄문에.
		- webEnvironment 의 DEFAULT 영역은 MOCK 이라, ㄷ밈나어리ㅏㅓ??
		- (((다시 들어볼 것.)))근데 이것을 MOCK 한다던지, 별개 설정이 없다면 DEFAULT 설정이 MOCK 이라서

- CICD 할 떄 자동화된 인수 테스트 작성할 떄... RestAssured 에 요청을 보낼 수도 있다.