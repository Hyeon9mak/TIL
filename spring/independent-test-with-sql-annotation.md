# Sql 어노테이션을 이용한 테스트 독립성 지키기

## 테스트 환경
- JUnit 5
- JDK 8
- Spring boot
- H2 memory database

<br>

## 사건의 발단
페어인 와이비와 테스트 코드 작성을 모두 마친 시점에서, 
테스트 코드 전체를 실행시켰을 때 테스트간 실행 순서에 따라 테스트 결과가 달라지는 이슈를 발견했다.

<br>

## 원인
원인을 찾아보니, 앞서 실행된 테스트 파일에서 H2 memory DB 테이블에 저장시킨 값이 그대로 다음 테스트 파일로 넘어와서 테스트가 수행되어, 중복 데이터 에러가 발생함을 확인할 수 있었다.

<br>

## 해결 시도 1 - @Transactional
`@Transactional` 어노테이션을 달아주면 테스트 수행 전 모든 Row를 삭제 시켜준다.

- 클래스 위에 붙여주면, `@BeforeEach` 처럼 모든 테스트 메서드를 수행하기전에 삭제시켜준다.
- 메서드 위에 붙여주면, 해당 테스트 메서드를 수행하기 전에만 삭제 시켜준다.

`@Transactional` 어노테이션은 테이블 데이터에 대한 롤백은 해소할 수 있었지만, 
auto-increment 로 증가하는 값에 대해서는 롤백을 수행하지 못했다.
(애초에 auto-increment 되는 값에 종속적이지 않은 테스트를 짜는게 좋겠지만)

auto-increment에 종속적이지 않은 테스트를 원한다면?  
테이블 자체를 완전히 DROP 하고 다시 생성하는게 차라리 편하다.

<br>

## 해결 시도 2 - @Sql
`@Sql` 어노테이션을 달아주면 `@Sql` 어노테이션에 지정해둔 경로의 sql 파일을 읽어서 
새로운 데이터베이스 테이블들을 구성한다.

이를 통해 테스트를 실행하기 전 별도의 쿼리문을 실행하게 할 수 있다.

- 클래스 위에 붙여주면, 모든 테스트 메서드를 수행하기 전에 .sql 파일의 쿼리문들이 실행된다.
- 메서드 위에 붙여주면, 해당 테스트 메서드를 수행하기 전에만 .sql 파일의 쿼리문들이 실행된다.

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Sql("classpath:initializeTable.sql")
@DisplayName("지하철역 관련 기능")
public class StationAcceptanceTest {
    ...
}
```

`DROP TABLE` -> `CREATE TABLE` 을 통해 완벽한 롤백을 수행시킬 수 있지만 치명적인 단점들이 존재한다.

- 테스트 하나를 이해하기 위해선 필수로 .sql 파일을 확인해야한다.
    - .sql 파일을 확인하지 않을 경우 테스트가 동작되는 환경(데이터셋)을 알 수 없다.
- sql 쿼리 문법에 익숙하지 않은 개발자의 경우 이해가 어려울 수 있다.

<br>

## 결론
결국 `@Sql` 어노테이션을 통해 해결했다. 그러나 왕도는 없다. 상황에 맞게 사용하자.
