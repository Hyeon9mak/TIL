# 스프링을 왜 사용하는가?

## 자바당 정파 기술 - EJB
자바 진영의 정파 기술.
(오픈 소스를 사파 기술로 여겼음)
지금으로 따지면 Spring과 JPA를 합쳐놓은 종합 선물 세트였다.
금융권이나 아키텍트 같은 사람들은 엄청 많이 사용하고 도입했다.
EJB가 쉽다는 듯이 기술 영업을 많이 했다.

오픈 소스를 사파로 여겼기 때문에 금융권 같이 
보안을 중시하는 회사를 상대로 영업이 굉장히 잘됐다.

컨테이너, 트랜잭션 설정, 계층서버 분산기술(서비스, DAO 등) 설정이 용이했다. 이론적으로 굉장히 강력함.
또, EJB라는 ORM 기술도 가지고 있었다.
근데 문제는, 비쌌다.
(요즘은 스프링 부트에 톰캣 다 무룐데!)

비용보다 더 큰 문제는, EJB의 지옥이다. 진짜 어렵고 복잡하고 느리다.
이론은 너무 좋은데, 어렵고 복잡하고 느림. 개발자들 죽어났다.
또, EJB 인터페이스에 의존적인 코드로 짜야한다.
이게 싫어서 순수하게 자바로 돌아가자고 탄생한 단어가 POJO다.

EJB 컨테이너를 대체하고, 단순하게 만든게 바로 스프링!
EJB 엔티티빈 기술을 대체, JPA의 새로운 표준이 된게 하이버네이트!
EJB 엔티티빈을 밀어붙이다가 망함을 인정하고 하이버네이트 개발자 게빈킹을 데려와서 JPA 표준을 만듬.
(EJB엔티티비 --> 하이버네이트 --> JPA)


<br>

## 스프링
스프링이라는 단어는 문맥에 따라 다르게 사용된다.

- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

중요한건 핵심 개념.
- 이 기술을 왜 만들었는가?
- 이 기술의 핵심 컨셉은?

새로운 기술을 배울 땐 핵심 컨셉을 이해하는게 가장 중요하다.
결국 핵심 컨셉을 이해하면 나머지 부차적인 것도 쉽게 이해할 수 있다.

스프링의 핵심 개념, 컨셉?
- 웹 애플리케이션을 만들고, DB 접근을 편리하게 해주는 기술?
- 전자정부 프렝미워크 이런게 핵심이 아니다.

진짜 핵심은 
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체지향
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
(EJB에 종속되는 개발을 막자, POJO로 돌아가자. 그걸 가능하게 만든 핵심이 DI, BEAN 컨테이너를 사용하기 시작한 것. 그것이 스프링)

결국 스프링에 종속적이다 - 자연스럽게 객체지향을 잘 따르게 된다.

<br>

## 객체 지향 특징
- 추상화
- 캡슐화
- 상속
- 다형성

객체지향이란 프로그램을 명령어 목록이 아닌, 독립된 단위, 객체간 대화로 보자는 것.
각각의 객체가 메세지를 주고 받고, 행동을 수행한다. (객체간 협력)
프로그램을 변화에 유연하게 만든다. 대규모 소프트웨어 개발에 많이 사용된다.

Q. 변화에 유연하다는데 코드 수정 개많이 해야하는데스?
- 레고 블럭 조립하듯이
- 키보드, 마우스 갈아 끼우듯이
- 컴퓨터 부품 갈아 끼우듯이
- 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법.

이걸 가능하게 하는 궁극의 유연함과 궁극의 객체지향 방법 = 다형성
왜 다형성이 중요한가?

- 실세계와 객체지향을 1:1로 매칭하면 안맞는다.
- 그래도 실세계의 비유로 이해하기엔 좋음
- **역할**과 **구현**으로 세상으로 구분해보자.

운전자 - 자동차
![image](https://user-images.githubusercontent.com/37354145/140676293-bdd9a34d-4d1d-4a97-b4b0-a6ba051dd309.png)

긍게 결국 자동차 역할이라는 인터페이스가 존재해서
운전자는 자동차 역할이라는 인터페이스에만 영향을 받기 때문에
실제 자동차 구현체가 바뀌어도 운전자는 영향을 받지 않는다.
유연하고 변경에 용이하다는 것이 이런 부분이다.
이것이 바로 다형성이다.

그렇다면 누굴 위해서 이런 다형성(인터페이스)를 구성했는가?
우리가 책에서 얼핏 배우기엔 '자동차'를 위해서 그랬다고 헷갈릴 수 있다.
그러나 앞선 설명에서 예상할 수 있듯이, '운전자'의 편의를 위해 
그런 다형성(인터페이스)를 사용했다.

덕분에 운전자는 자동차가 어떻게 만들어졌는지 알 필요 없고, 운전법도 바꿀 필요가 없다. 
즉, 중요한 것은 자동차 역할을 통해 새로운 자동차를 얼마나 만들 수 있느냐가 아니라, 자동차 역할을 통해 운전자가 새로운 운전법을 배울 필요가 없는 것이 중요한 것이다.

![image](https://user-images.githubusercontent.com/37354145/140676673-debc9fdf-c191-403e-abd7-bfccf8aaa68f.png)

역할에 대한 대체 가능성이 생기는 것.

### 역할과 구현을 분리
- 역할과 구현으로 구분하면 세상이 단순해지고 유연해지며 변경도 편리해진다.
- 장점
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
    - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
    - 클라이언트는 구현 대상의 내부구조가 변경되어도 영향이 없다.
    - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.

### 자바 언어
- 자바 언어의 다형성을 활용
    - 역할 = 인터페이스
    - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현체 만들기

즉, 본질은 클라이언트(요청자)를 변경하지 않고 서버(응답자)를 변경할 수 있는 것.

한계점은 없나?
- 역할, 인터페이스 자체가 변하면 클라이언트와 서버 모두 변경이 발생한다.
- 때문에 인터페이스를 안정적으로 잘 설계하는 것이 가장 중요하다.

### 스프링과 객체지향
- 다형성이 가장 중요하다!
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전(IoC), 의존 관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 마치 레고 블럭 조립하듯이 구현을 편리하게 변경할 수 있다.

<br>

## 좋은 객체지향 설계의 5가지 원칙 - SOLID

### SRP(Single responsibility principle) - 단일 책임의 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호하다.
    - 클 수 있고, 작을 수 있다.
    - 문맥과 상황에 따라 다르다.
- **중요한 기준은 변경**이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
- ex) UI 변경, 객체의 생성과 사용을 분리

### OCP(Open/Close principle) - 개방/폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 이런 거짓말 같은 말이? 확장을 하려면, 당연히 기존 코드를 변경?
    - 다형성을 활용해보자.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 지금까지 배운 역할과 구현의 분리를 생각해보자.

- `MemberService` 클라이언트가 구현 클래스를 직접 선택
    - `MemberRepository m = new MemoryMemberRepository();`
    - `MemberRepository m = new JdbcMemberRepository();`
- 구현 객체를 변경하려면 클라이언트 코드가 변경되어야만 한다.
- 분명 다형성을 사용했지만, OCP 원칙이 무너지고 있다.
    - 이 문제를 어떻게 해결해야 하나?
- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
    - 그게 바로 스프링이다!! DI, IoC 컨테이너를 사용하는 이유도 이것.

### LSP(Liskov Subsitution principle) - 리스코프 치환 원칙
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.
    - 다형성을 지원하기 위한 원칙,
    - 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기
- 결국 클라이언트가 기대하고 있는 기능을 무조건 보장해야 한다.
- ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리게 가더라도 어쨌든 앞으로 가야함.

### ISP(Interface Segregation principle) - 인터페이스 분리 원칙
- 특정 클라이언트를 ㅜ이한 인터페이스가 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에는 영향이 없음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP(Dependency inversion principle) - 의존관계 역전 원칙
- 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 중비은 이 원칙을 따르는 방법 중 하나다.
- 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- 앞서 이야기한 역할에 의존하라는 것과 완전히 동일한 이야기다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다! 구현체에 의존하게 되면 변경이 아주 어려워 진다.

- 그런데 OCP에서 설명한 `MemberService`는 분명히 `MemoryMemberRepository`와 `JdbcMemberRepository`를 분명히 의존하고 있다.
- 때문에 `MemberService` 클라이언트가 구현 클래스를 직접 선택, DIP를 위반하고 있다.

<br>

### 정리
- 객체 지향의 핵심은 다형성
- 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함꼐 변경된다.
- 다형성 만으로는 OCP와 DIP를 지킬 수 없다.
- 뭔가 더 필요하다.

### 다시 스프링으로
스프링 이야기에 왜 객체지향 이야기가 나오는가?

- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
    - DI(Dependency Injection): 의존관계, 의존서 ㅇ주입
    - DI 컨테이너 제공
- 클라이언트 코드의 변경없이 기능 확장
- 쉽게 부품을 교체하듯이 개발

### 정리 - 실무 고민
- 인터페이스를 동비하면 추상화라는 비용이 발생한다.
- 당장 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 추후 꼭 필요할 때 리팩토링 과정에서 인터페이스를 도입하자. 
