## @Transactional
트랜잭션은 ACID의 성질을 가진다

- Atomicity(원자성) : 한 트랜잭션 내에서 실행한 작업들은 하나로 간주한다. 모두 성공, 모두 실패만 존재하며 부분 성공 등은 존재하지 않는다.
- Consistency(일관성) : 트랜잭션은 일관성 있는 데이터베이스 상태를 유지한다.
  예를 들자면 A통장에서 B통장으로 계좌이체를 한 후에도, A통장과 B통장 계좌 잔액의 합이 동일해야한다. 또, Key의 속성이 변화한다던지의 이벤트가 발생해선 안된다.
- Isolation(고립성, 독립성) : 트랜잭션이 동작하던 중에 또 다른 트랜잭션과 통신을 한다던지의 행동이 발생해서는 안된다. 동시에 2개 이상의 트랜잭션이 동작을 한다더라도, 동작 중에 서로간의 간섭이 절대 없어야 한다.
  동작이 끝난 후의 간섭에 대해서는 상관없다.
- Durability(지속성) : 데이터 변화가 일어났을 때 변화된 내용이 유지(저장)가 되어야 한다.

스프링에서는 `@Transcational` 어노테이션을 사용해서 선언적 트랜잭션을 진행한다.
클래스나 메서드 위에 붙여서 사용할 수 있으며, 붙인 곳에 트랜잭션 기능이 적용된다.

### 트랜잭션 우선순위
클래스 메소드 > 클래스 > 인터페이스 메소드 > 인터페이스

### CRUD Transactional
Create/Update/Delete 는 테이블에 변화를 일으키기 때문에 트랜잭션을 거는 것이 추천된다.
그러나 Read는 트랜잭션을 거는 것에 신중해야한다. (거의 걸면 안된다.)

예를 들어 1개의 서비스에서 2개의 데이터베이스(A, B)를 조회하려고 할 때, B 데이터베이스에 문제가 발생했을 경우 서비스는 트랜잭션을 지키기 위해서 B 데이터베이스의 문제가 해결될 때 까지 기다리려고 한다. (트랜잭션을 걸지 않았을 경우 바로 예외를 던지며 실패할 수 있다.)

이 때문에 Read 쪽에는 트랜잭션을 거는 것에 신중해야한다.
(나중에 현업 단계에서는 더 많은 고려사항이 존재하지만, 현재는 이렇게 이해하고 넘어가자)

### 그렇다면 Controller 계층에는 @Transactional 어노테이션을 붙일 수 없나?
결론 : 붙여도 아무런 효과가 없다.
우선 Spring AOP에서 기본적으로 다이나믹 프록시 기법을 사용해 동작하는데, 다이나믹 프록시 기법에는 인터페이스가 필요하다. 그런데 Controller 클래스는 일반적으로 인터페이스를 가지고 있지 않기 때문에, @Transactional 어노테이션을 붙여도 동작을 하지 않는다.
그와 별개로, Controller는 통신을 주고 받기도 바쁜 계층이다. Controller 클래스에서는 단순히 HTTP 요청에 맞게 비지니스 로직을 호출하는 구조로 설계하자.

<br>

## @Transcational(readOnly = true)
`@Transcational(readOnly = true)` 옵션은 트랜잭션 간의 커밋/롤백 등을 보장해주는 옵션이 아니다.
하나의 트랜잭션 내부에서 C/U/D 동작이 일어나지 않고 R만 일어나기를 기대하는 옵션이다.
즉, Read 동작 외에 C/U/D 동작이 수행될 경우 `@Transcational(readOnly = true)` 옵션은 예외를 발생시킨다.

그렇다면 우테코 미션 중에 `@Transcational(readOnly = true)` 의 효과를 왜 실감하지 못했는가?

첫 번째 이유로 MySQL을 사용했기 때문이다. MySQL DBMS의 스펙상 `@Transcational(readOnly = true)` 옵션의 효과가 거의 없다고 한다. 
두 번째 이유로 진행한 미션들의 조회 관련 서비스 레이어 메서드가 매우 간단했기 때문이다. 
사실상 다른 C/U/D 작업 없이 순수하게 Read 작업을 1회만 수행하는 등 서비스 레이어 메서드가 매우 간결했기 때문에 
`@Transcational(readOnly = true)` 의 효과를 실감하기 어려운 환경이었다.

우테코 미션 수준에서 `@Transcational(readOnly = true)`의 효과를 기대해 볼 수 있는 상황으로는

- 서비스 레이어 메서드에는 Read만 수행하도록 했으나 실수로 DAO쪽에서 C/U/D 동작을 추가하는 경우 방지
- @DirtiesContext 어노테이션이 의도치 않게 동작되는 경우 방지

가 있겠다.

실제 현업에서는 우리가 알고 있는 서비스 레이어가 한 단계 더 분화한다고 하는데, 더욱 더 많이 추상화 되어 있는 하나의 명령을 소화하기 위해 
동시에 여러가지 C/R/U/D 동작이 수행될 것이고, 바로 이 때 조회만 수행해야하는 동작에서 의도치 않게 C/U/D 작업이 혼용되는 것을 막기 위해 
사용할 수도 있지 않을까? 라는 생각이 든다.

<br>