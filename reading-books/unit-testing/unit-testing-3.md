# 단위 테스트 구조
## 단위 테스트를 구성하는 방법
### AAA 테스트 패턴 사용
준비, 실행, 검증 3가지 파트로 나뉜다.

```java
@DisplayName("Member가 Sitter로 등록된다.")
@Test
void getSitterJob() {
    // 준비
    Member member = new Member(
        "최현구",
        LocalDate.of(1996, 2, 7),
        "남",
        "hyeon9mak",
        "abc123!",
        "hyeon9mak@mfort.co.kr"
    );

    // 실행
    member.addRole(new Sitter(3, 5, "잘해요"));

    // 검증
    assertThat(sitter.getMember()).isEqualTo(member);
    assertThat(member.getSitter()).isEqualTo(sitter);
}
```

- 준비 구절에서는 철저히 테스트 대상 시스템과 해당 의존성을 원하는 상태로 준비한다.
- 실행 구절에서는 테스트 대상 시스템에서 메서드를 호출하고 준비된 의존성을 전달하며 출력값을 저장한다.
- 검증 구절에서는 출력 결과를 검증한다.

이렇게 AAA 패턴을 이용해 테스트를 작성할 경우 아래와 같은 장점이 있다.

- AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다.
- 쉽게 읽고 이해할 수 있다. 일관성이 가장 큰 장점이다.
- 결국 전체 테스트 관리에 대한 유지보수 비용이 줄어든다.

> Given-When-Then 패턴과 굉장히 유사하다.
> 책 저자의 말에 따르면 Given-When-Then 패턴과의 차이점은 
> Given-When-Then 패턴이 보다 더 비개발자가 읽기 쉬운 차이라고 한다.
>
> AAA 패턴은 비교적 raw 하게,
> Given-When-Then 패턴은 팩터리 메서드 등을 통해서
> 문장형으로 읽기 쉽게 작성함을 의미하는 것 같다.

### 테스트 구절 작성
- TDD를 진행할 땐 검증 구절부터 작성하면 좋다.
- 그 외엔 준비 구절부터 차례대로 작성할 것.
- 일반적으로 준비 구절이 모든 구절 중에 가장 많은 분량을 차지한다.
    - 준비 구절이 지나치게 길어지면 메서드로 추출해서 가독성을 올려보자
- 실행 구절이 2개 이상되면 '단위 테스트'라고 보기 어렵다. 통합 테스트나 마찬가지.
    - '단위'의 기준은 '동작'
    - 2개 이상의 동작이 포함된 것이므로 테스트 분리가 필수적이다.
- 실행 구절이 2개 이상인 경우, 각각의 실행 구절이 포함되지 않으면 결과에 모순이 생긴다.
    - 이는 캡슐화가 깨졌다는 증거로도 볼 수 있다.
    - 테스트 단위는 최대한 작게, 1개의 동작만 검증하자.
- 테스트 내에 `if` 문이 존재한다면 한 번에 여러 동작을 검증하려 한다는 것이다.
    - 이 역시도 테스트를 분리하자.
- 검증 구절은 많아질 수 있으며, 하나의 테스트에서 최대한으로 검증하는게 좋다.
    - 그러나 이 역시도 지나치게 커지면 추상화가 부족함을 인식해야한다.

### 테스트 픽스처 재사용
준비 구절의 코드가 지나치게 반복된다면 픽스처로 재사용을 고려해보는 것이 좋다.
그러나 무조건적인 픽스처 사용은 유지보수 비용을 크게 늘린다.
픽스처를 준비할 때 고려해야할 점은 크게 2가지다.

- 테스트 가독성
    - 테스트 메서드를 하나 읽을 때도 픽스처를 계속해서 참고해야한다.
- 테스트 간 결합도
    - 픽스처 하나를 수정했을 때 모든 테스트가 실패할 수도 있다.
    - 이는 하나의 테스트가 다른 테스트에 영향을 주어서는 안된다는 지침을 위반한다.

이와 같은 문제점은 주로 픽스처용 static 변수를 만들어두거나,
필드 변수 값을 생성자에서 할당할 때 일어난다.
대부분의 경우 팩터리 메서드를 통해 픽스처를 준비하면 보다 더 나은 결과를 얻을 수 있다.

<br>

## 좋은 단위 테스트 명명법
- 엄격한 명명 정책을 따르지 않는다. 복잡한 동작에 대한 높은 수준의 설명을 이러한 정책의 좁은 상자 안에 넣을 수 없다. 표현의 자유를 허용하자.
- 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자. 
- 테스트 명에 테스트 대상의 이름을 포함하지 마라
    - 검증해야할 것은 대상의 '동작'이지, 대상이 아니다.
    - 테스트 대상이 변경될 경우 테스트 명을 고쳐야한다. (유지보수 비용 증가)

<br>

## 매개변수화된 테스트 작성
하나의 동작에 대해 여러가지 입력 값을 검증해야할 때가 있다. (입력 값마다 결과가 다른 경우)
이럴 때는 같은 동작을 가진 테스트를 여러 개 작성하는 것보다, 매개변수화된 테스트 작성을 고려해보는 것이 좋다. 가령 예시를 들자면 아래와 같다.

```java
@ParameterizedTest
@ValueSource(ints = {1, 3, 5, -3})
void isOdd_ShouldReturnTrueForOddNumbers(int number) {
    assertTrue(Numbers.isOdd(number));
}
```

그러나 매개변수화된 테스트를 작성하면 유지보수 비용이 조금씩 증가한다.
특히 매개변수 개수가 많아질수록 그렇다.
이럴 때는 긍정적인 테스트 케이스와 부정적인 테스트 케이스를 분리해두면
조금 더 나은 가독성을 확보할 수 있다.

<br>

그 외에도 xUnit, JUnit 등의 테스트(검증문) 라이브러리를 사용해서 더 뛰어난 가독성을 확보하면 좋다.
