# 10장. 실시간 게임 순위표

온라인 게임의 리더보드, 순위표 설계.

<br>

## 설계 범위

### 기능 요구사항

1. 순위표에 상위 10명의 플레이러를 표시한다.
2. 특정 사용자의 순위를 표시한다.
3. 어떤 사용자보다 4순위 위 아래 있는 사용자들을 표시한다.

### 기능 요구사항

- 점수 업데이트는 실시간으로 순위표에 반영한다.
- 일반적인 확장성, 가용성 및 안정성 요구사항

### 개략적 규모 추정

DAU 가 5,000,000 명인 게임에서 사용자가 24시간동안 고르게 분포한다고 가정하면
`24H = 1,440m => 86,400s`, `5,000,000 / 86,400 = 58.0` 이므로 초당 약 50명의 사용자가 게임을 플레이하는 걸로 계산 가능하다.

그러나 온라인 게임이 이렇게 균등한 경우는 거의 없고, 저녁시간이 피크인 도메인적 특성을 갖고 있다.
이를 감안하여 최대 부하는 평균의 5배라고 가정한다. 그럼 초당 최대 250명의 사용자를 감당해내야 한다.

기능 요구사항 2번과 3번을 달성하기 위해서는 우선 사용자 점수 획득 QPS 를 계산해야한다.
한 사용자가 평균 10개의 게임을 플레이한다고 가정하자. 
초당 사용자수는 평균 50이므로, `50 * 10 = 500` 이므로 초당 500개의 게임이 플레이된다.
최대 QPS 는 평균의 5배로, `2,500` QPS 가 된다.

기능 요구사항 1번을 달성하기 위해서는 사용자가 순위표를 얼마나 확인하는지를 계산해야한다.
상위 10명 순위표를 게임을 열 때만 1번 표기한다고 하면 QPS 는 약 `50` 이다. 

<br>

## 설계안 제시

크게 3가지 API 를 구상할 수 있다.

1. 게임 승리시 사용자 순위 갱신 API
2. 특정 사용자의 순위 가져오기 API
3. 상위 10명 플레이어 가져오기 API

<img width="449" alt="image" src="https://github.com/user-attachments/assets/b3233f4d-3cca-4360-9227-fc71b1b48919">

이 가운데서 몇 가지 추가 고민을 해볼 수 있는데, 각각 채택하지 않은 이유를 이야기해보자.

### 클라이언트가 순위표 서비스와 직접 통신 해야하나?

클라이언트가 점수를 정하고 순위표 서비스에 등록하는 방식. 이 방식은 사용자가 프락시를 설치하고 마음대로 점수를 바꿀 수가 있어서 보안상 좋지 않다.
resource 를 통제하는 행위는 어지간하면 server 에게 조두권을 넘기자. 추후 비즈니스적으로 점수 산정 로직이 바뀐다던지 여러가지 상황에 유연하게 대응하기에도 좋다.

<img width="585" alt="image" src="https://github.com/user-attachments/assets/e00ecc38-c492-421a-8731-1aba5e1403a5">

또한 게임 서비스 구조상 언제, 어느 타이밍에 순위를 갱신해야하는지도 게임 서비스가 모두 알고 있기 때문에,
가능하면 서버(게임 서비스 등)를 통해 진행하는 것이 좋겠다.

1. 클라이언트와 통신 횟수도 줄어드니 더 좋다.
2. 클라이언트가 존재를 인지하는 도메인(서버)의 개수가 적으면 적을수록 변화에 더 유연하게 대응할 수 있다.
   1. 많으면 많을수록 클라이언트가 모든 도메인의 변화에 영향을 받게 된다. (캡슐화)

### 게임 서비스와 순위표 서버 사이에 메세지 큐가 필요한가?

게임 점수가 어떻게 사용되는지에 따라 크게 달라진다.
해당 데이터가 다른 곳에서 이용되거나 여러 기능을 지원해야한다면 합리적일 수 있다. (TOPIC 을 구독하는 구조. LIKE SNS-SQS.)

<img width="659" alt="image" src="https://github.com/user-attachments/assets/a68670bb-ab64-40ee-b809-39619b7940f0">

그러나 꼭 그래야할 환경이 아니라면 굳이 설계를 복잡하게 만들 필요는 없지.

### 데이터 모델

- RDB
  - 규모 확장성이 크리티컬 하지 않고 사용자 수가 적다면 RDB 를 채택할 법하다. 제일 대표적이고 편하니까.
  - 그러나 데이터가 수백만개로 늘어나면 성능이 급격히 나빠진다.
  - 수시로 데이터 CUD 가 발생하는 환경이라 적합하지 않다.
    - 조회 성능을 위해 매번 정렬을 해줄 것인데, 정렬 자체가 큰 부담이다.
  - 데이터가 계속 변경되기 때문에 캐시 도입도 어렵다.
  - 특정 사용자의 순위를 찾기에도 좋지 않다. 계속해서 Full Table Scan 이 발생할 것이다.

- Redis
  - sorted set 자료구조가 너무 맛돌이라 써먹기 딱 좋다.
  - sorted set 은 내부적으로 해시 테이블과 스킵 리스트라는 2가지 자료구조를 이용한다.
    - 스킵 리스트: LL 에 다단계 index 를 두는 구조.
    - (java hashMap 과 구조가 유사한듯)
  - LL 구조에서 아래 그림과 같이 다단계 색인을 추가하여 탐색속도를 높이는 방식 (Binary Tree 구조를 그리게 된다.)
    - 정렬은 어떻게 할까? B+Tree 와 같이 색인을 타고 리프노드로 이동 후 자신을 추가하면 끝이다.
      - 꼭 모든 색인이 균형을 이루고 있을 필요는 없겠다. 여유가 될 때 한번씩만 정리해주면 됨.

![IMG_078F81F148F7-1](https://github.com/user-attachments/assets/d908fe1d-35d0-4015-852e-31a68bbf1d76)

![IMG_B6B49D7572C0-1](https://github.com/user-attachments/assets/792949eb-fa20-4aa9-b24e-402bc090f8f1)

그리고 Redis sorted set 이 제공하는 여러가지 명령어(`ZADD`, `ZINCRBY`, `ZRANGE`, `ZRANK`)를 통해 이를 손쉽게 다룰 수 있다.
이를 통해 순위표를 너무나 쉽게 표현 가능!

### 저장소 요구사항

오케이 좋았어. 그럼 레디스의 스펙은 어떻게 결정하면 좋을까?

- 메모리(캐시)
  - 최악의 경우의 수는 월간 전체 활성 사용자가 한번 이상 게임에서 승리해서 순위표에 오르는 경우다. 
  - ID 가 24자 문자열이고, 점수가 16비트 정수라고 한다면 순위표 한 항목당 26바이트가 필요하다.
    - `26 * 25,000,000 = 6억 5,000만` = `650MB` 의 레디스 공간이 필요하다. 
    - sorted set 자료구조 특성을 감안해서 메모리를 2배로 넉넉잡는다고 해도 1.3기가바이트다. 
  - 요즘 컴퓨팅 자원에 1.3 기가바이트가 그리 부담스러운 건 아니다. redis 인스턴스 1대로도 충분하다.
- CPU, I/O
  - 최대 QPS 는 2,500
  - 역시나 요즘 컴퓨팅 자원에 충분...

유일한 문제점은 영속성. RDB 에 따로 보관하는 방법도 있지만 속도가 너무 느리다.
결국 RDB 와 같이 사본(replication) 방식을 고안하게 된다. redis 는 PUB/SUB 방식으로 이를 보완한다.

pub/sub 없이 RDB 를 이용하는 경우에는 복구용 테이블을 가능하면 간단하게 구성하자.

성능 최적화 방안 중 하나는 자주 검색되는 상위 10명의 사용자 정보를 캐싱해두는 것이다.
사용자는 상위 10명과 내 등수 정도에만 관심을 갖는다. 그리고 상위 10명은 잘 변경되지 않는다.

![IMG_CE09A382CB54-1](https://github.com/user-attachments/assets/4185738e-6727-425e-a1e3-845e8ef7408d)

항상 서비스 특성을 고려하여 최적화 대상을 채택하면 되겠다.

<br>

## 상세 설계

### 자체 구축 혹은 클라우딩 서비스 활용

AWS 와 같은 클라우딩 서비스를 이용하는 경우 꼭 자체 서버를 구축하지 않더라도
서버리스한 순위표 서비스를 구성할 수 있다.

<img width="766" alt="image" src="https://github.com/user-attachments/assets/42ed3c56-b37c-48ec-a42d-dd7f8f9ead5b">

### 레디스 규모 확장

DAU 가 적다면 한 대의 레디스로도 충분히 서비스 지원이 가능하다.
그러나 5억 DAU 정도라면 어떨까? 최악의 경우 저장 용량이 65GB 까지 필요하고,
250,000 QPS 질의를 처리할 수 있어야 한다. 이정도면 샤딩이 필요할 수 밖에 없다.
무얼 기준으로 샤딩을 해야할까?

![IMG_C300E1074CA7-1](https://github.com/user-attachments/assets/e0c01621-f410-4311-aa77-332fcdb5b372)

**고정 파티션**

- 순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방식이다.
- 이 기능이 제대로 동작하려면 순위표 전반에 점수가 고르게 분포되어야 한다.
  - 그렇지 못하면 당연히 핫스팟이 탄생한다.
- 어쩔 수 없이 애플리케이션이 샤딩 처리의 주체가 되기 시작한다.
  - 매번 어떤 샤드에 원하는 데이터가 있는지 찾아내야한다.
  - Query 를 통해 현재 사용자의 점수를 계산하여 알아내는 것도 방법
  - 하지만 사용자 ID 와 점수 사이의 관계를 저장하는 2차 캐시를 두어 성능을 높일 수 있다.
    - 대신 당연하게도 복잡도가 올라간다.
  - 사용자의 점수가 변경되어 샤드를 이동해야하면 기존 샤드의 정보도 지워야한다.
  - 과연 인프라의 과오를 애플리케이션이 감당하는게 맞을까? 유지보수 겁나 힘들듯.

**해시 파티션** (젠장 Redis 또 너야?)

레디스 클러스터를 이용하는 방법도 있다. 사용자들의 점수가 특정 대역에 과도하게 모여있는 경우에 효과적이다.

> 롤과 같은 랭킹 시스템이 딥한 게임을 해본 사람은 알겠지만, 특정 대역에 과도하게 몰리는게 너무나 당연하다.

Redis 는 자체적으로 클러스터 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공한다.
안정해시를 사용하는 건 아니지만, 각각의 키가 특정한 해시슬록(hash slot)에 속하도록 하는 샤딩 기법이다.

<img width="653" alt="image" src="https://github.com/user-attachments/assets/36b4a6de-5496-4640-8ea7-1eb07de25327">

키 값으로 계산 후 해당 노드에 찾아가기만 하면 된다.
상위 10명을 한꺼번에 찾기가 귀찮아지는데, 각 노드를 병렬로 뒤질 수 있도록 설정해주면 조금 더 개선해볼 수 있다.

그러나 해시 파티션도 완벽한 해답은 아니다.

1. 상위 n 명 조회의 경우 병렬로 조회해도 어차피 다 모아서 정렬해야한다. 즉, 가장 느린 파티션이 최종 지연시간이 된다.
2. 특정 사용자의 순위를 결정할 간단한 방법이 없다.

결국 다른 방식을 사용해봐야한다.

**고정 파티션**

<img width="559" alt="image" src="https://github.com/user-attachments/assets/22bfd5e8-d88b-4752-a3b4-d142832052f1">

각 반에 반장 한명씩 두고 휘하를 통솔하는 분산-수집 방식.

이 방식을 채택할 땐 메모리가 얼마나 필요할지 확인해야하는데, 이 때 [redis-benchmark](https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/benchmarks/) 라는 도구를 사용하면 좋다.
(추가 참고 - [https://devocean.sk.com/blog/techBoardDetail.do?ID=166040&boardType=techBlog](https://devocean.sk.com/blog/techBoardDetail.do?ID=166040&boardType=techBlog))

이것도 좀 그래... 기깔난 대안은 없을까?

### NoSQL

그런 당신을 위해 준비했습니다!

- 쓰기 연산에 최적화 되어 있고,
- 같은 파티션 내 항목을 점수에 따라 효율적으로 정렬할 수 있는 NoSQL!

대표적으로 DynamoDB, MongoDB 등을 활용하면 된다.

![IMG_2121030E28F9-1](https://github.com/user-attachments/assets/354c4c84-721a-4c4d-94e4-30d39c1ab66f)

NoSQL 의 장점이 무엇인가? 서비스에 활용 가능한 형태로 데이터를 비정규화하고, 거기에 질의를 하는 것이다.
비정규화는 모든 서비스를 다룰 수 있게 정보를 담는게 아니라, 각 서비스마다 하나씩 비정규화 테이블을 만드는 것이다.

다만 이 방식은 데이터가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤져야해서 성능이 떨어진다.
이럴 땐 게임을 파티션 키로, 점수를 정렬 키로 사용하는 것으로 개선해볼 수 있다.

<img width="646" alt="image" src="https://github.com/user-attachments/assets/c6a84f9d-7280-4b2f-90af-a92e0c402ec7">

그래도 문제가 있을 수 있는데! 이번엔 부하가 높을 때가 문제다.
위 그림대로 구조를 만들면 최근 한달치 데이터가 동일한 파티션에 저장되어 핫스팟이 되고 만다.

한 가지 방법은 데이터를 파티션 n개로 분할하고, 파티션 번호를 파티션 키에 추가하는 것이다. (쓰기 샤딩 패턴)
하지만 이 방법은 읽기 쓰기 작업을 모두 복잡하게 만들어서 신중하게 선택해야한다.

그리고 파티션을 나누면 나눌수록 데이터 하나를 쓸 때 파티션 하나가 받는 부담은 적어지지만, 데이터를 범위로 조회할 때는
전체 파티션을 뒤져봐야해서 부하가 커질 수 있음을 이해해야 한다. 읽기와 쓰기간 부하 트레이드 오프가 있다.

결국 어떻게 하라고? 위에 고려한 모든 걸 적용해서 분산 수집 구조를 다시 갖도록 하면 된다.
NoSQL 은 Redis 와 다르게 메모리를 크게 쓰는 방식이 아니므로 그리 부담이 아니다.

![IMG_705FE8B2DD06-1](https://github.com/user-attachments/assets/54a12467-fdc0-4af3-a929-23b9401c1ec2)

최상위 10명의 사용자 정보를 가져오려면 각 파티션에서 상위 10개의 결과를 가져온다음 애플리케이션에서 결과를 모아 정렬한다.
왜 10개일까? 파티셔닝 기준이 불규칙해서 한 파티션에 10명이 다 몰려있을 가능성도 존재하기 때문이다.

<img width="653" alt="image" src="https://github.com/user-attachments/assets/96c6f3ee-df2f-48ee-bc92-2917f2742fd0">

앞서 이야기한 Redis 기법과 마찬가지로, 사용자의 전체 순위를 빠르게 찾아내기 매우 어렵다.
서비스 특성을 이용해서 꼼수를 부려보자면, 대부분의 사용자는 꼭 정확한 순위를 알 필요가 없긴하다.
상위 10~20% 군에 속한다고 이야기 해주는 것 만으로도 충분히 만족할 수도 있다.

데이터 규모가 충분히 커서 샤딩을 해놓은 상황이라면, 모든 샤드의 점수 분포는 거의 동일하다고 볼 수 있다. 그걸 이용해서
각 샤드의 점수 분포를 분석한 결과를 캐싱해놓을 수도 있다.

<br>

## 마무리

1. RDB 로 시작했지만 수백만명을 지원할 방법이 마땅치 않아 채택하지 않았다.
2. Redis 의 sorted set 도 사용했지만, 5억 DAU 메모리를 감당할 수가 없다.
3. 대안으로 NoSQL 까지 오게 되었다.

조금 더 성능을 개선해보자면 NoSQL 에 사용자 관련 정보를 모두 빼고, ID 만 갖도록 한다. 그리고 사용자 정보들을 Redis 에 적재한다.

레디스 클러스터에도 대규모 장애는 발생할 수 있다. 사용자가 게임에서 이길 때마다 RDB 에 타임스탬프와 함께 기록한다면
사용자별로 모든 레코드를 훑으면서 레코드당 한번씩 ZINCRBY 를 호출하는 것으로 쉽게 복구가 가능하다.
