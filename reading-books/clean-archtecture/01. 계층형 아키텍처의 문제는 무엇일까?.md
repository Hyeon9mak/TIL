web 계층에서 요청을 받아 domain 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다. 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 persistence 계층의 컴포넌트를 호출한다.

계층형 아키텍처는 매우 견고하다. 계층을 잘 이해하고 구성한다면 web, persistence 계층으로부터 독립적인 domain 계층 로직을 작성할 수 있다. 잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고 변화하는 요구사항과 외부 요인에 빠르게 적응하게 해준다. 그리고 이것이 아키텍처의 전부다.

그러나 계층형 아키텍처는 코드에 나쁜 습관이 스며들기 쉽고 시간이 지날수록 소프트웨어를 변경하기 어렵게 만드는 허점들이 노출된다.

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
  
![](https://i.imgur.com/bsdjm5n.png)

정의에 따르면 전통적인 계층형 아키텍처의 토대는 데이터베이스다. 의존이 persistence 계층으로 흐르기 때문에 모든 것이 persistence 를 토대로 만들어진다. 그리고 이 방식은 다양한 문제를 초래한다.

우리는 대부분의 애플리케이션을 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만들어 활용한다. 우리는 상태(state)가 아니라 행동(behavior)를 중심으로 모델링한다. 행동이 객체의 상태를 바꾸는 주체다.

**그렇다면 우리는 왜 도메인 로직이 아닌 데이터베이스를 토대로 아키텍처를 만들어야하는가?**

전통적인 계층형 아키텍처에서는 domain 보다 persistence 계층을 먼저 구현하는게 합리적인 방법이다. (의존성 방향 때문에) 하지만 비즈니스 관점에서는 전혀 맞지 않는 방법이다. 다른 무엇보다 domain 을 먼저 만들어야한다. 그래야 로직을 제대로 이해했는지 확인할 수 있다. domain → persistence → web

DB 중심 아키텍처가 만들어지는 가장 큰 원인은 ORM 때문이다. ORM 을 계층형 아키텍처와 결합하면 domain 규칙을 persistence 와 섞고 싶은 유혹을 쉽게 받는다.

![](https://i.imgur.com/OQbcp5u.png)

ORM 엔티티들은 일반적으로 영속성 계층에 둔다. 계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에서는 엔티티에 접근할 수 있다. 그리고 이러한 엔티티에 접근할 수 있다면 분명 내부에 도메인 로직이 추가되기 마련이다. 이렇게 되면 계층사이 결합이 생긴다. 서비스가 영속 모델을 비즈니스 모델처럼 사용하고, 영속 모델 내부에는 비즈니스 모델과 로딩전략, 트랜잭션, 캐시 플러시 등이 뒤섞인다.

> 📝 ORM 엔티티에 비즈니스 로직을 녹이고 싶은 욕심이 생긴다. ORM 연관관계가 가져오는 복잡한 코드가 비즈니스 로직에 녹기 시작한다. 관리가 어려워진다. ORM 을 제거하고자 할 때도 ORM 연관관계를 이용한 로직이 발목을 붙잡아 제거가 어려워진다.

유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정반대가 된다.

## 지름길을 택하기 쉬워진다.

전통적 계층형 아키텍처는 같은 계층이나 아래 계층으로만 의존이 흘러야 한다. 이거 말고는 이렇다할 규칙이 없다.

> 개인적으로는 같은 계층이더라도 가능하면 수평으로 의존이 흐르면 안됨. 패키지로라도 작은 단위의 계층을 분리해두는게 차후 관리에 용이하다.
  
따라서 상위 계층에 위치한 컴포넌트에 접근해야할 때, 이 문제를 해결하기 위해 해당 컴포넌트를 하위 계층으로 내려버리는 일이 발생할 수도 있다.

![](https://i.imgur.com/Eb9P0m3.png)

한번이 어렵지 그다음은 쉽다. 깨진창문 효과.

## 테스트가 어려워진다.

또 다르게 창문을 깨는 일이 있다. 계층을 건너뛰는 것이다.

![](https://i.imgur.com/1X2O5zp.png)

첫 번째 문제는 도메인 로직을 웹 계층에 구현하게 된다는 것이다. 만약 앞으로 유스케이스가 확장된다면 어떻게 될까? 아마도 더 많은 도메인 로직을 웹 계층에 추가해서 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높다.

두 번째 문제는 웹 계층 테스트에서 도메인이 아닌 영속성 계층을 모킹 (mocking) 해야 한다는 것이다. 이렇게 되면 단위 테스트의 복잡도가 올라간다. 그리고 테스트 설정이 복잡해지는 것은 테스트를 전혀 작성하지 않는 방향으로 가는 첫걸음이 다. 왜냐하면 복잡한 설정을 할 시간이 없기 때문이다.

> 테스트는 가장 먼지 포기할 수있는, 스터디와 같은 존재

시간이 흘러 웹 컴포넌트의 규모가 커지면 다양한 영속성 컴포넌트에 의존성이 많이 쌓이면서 테스트의 복잡도를 높인다. 어느 순간에는 실제로 테스트 코드를 작성하는 것보다 목(mock)을 만드는 데 더 많은 시간이 걸린다.

## 유스케이스를 숨긴다.

기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 아키텍처는 코드를 빠르게 탐색하는데 도움이 돼야 한다. 이런 관점에서 계층형 아키텍처는 어떻게 우리의 발목을 잡을까?

계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다. 유스케이스가 간단해서 도메인 계층을 생략한다면 웹 계층에 존재할 수도 있고, 도메인 계층과 영속성 계층 모두에서 접근할 수 있도록 특정 컴포넌트를 아래로 내렸다면 영속성 계층에 존재할 수도 있다. 이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워진 상태다.

![](https://i.imgur.com/HE1yVwW.png)
  
또한 여러 유스케이스를 담당하는 아주 넓은 컴포넌트가 만들어지기도 한다. 넓은 컴포넌트는 하위 계층에 많은 의존성을 갖게 되고, 상위 계층의 많은 컴포넌트가 넓은 컴포넌트를 의존하게 된다. 테스트도 어렵고 유지보수도 어려워진다.

유스케이스 하나당 하나의 컴포넌트만 만들면 이런 작업들이 얼마나 쉬워질까? 사용자 회원가입에 대해서 `UserService` 와 `RegisterUserService` 중 어떤게 더 찾기 쉬운가? 패키지와 클래스를 나누는 기준은 항상 “유지보수”가 되어야 한다.

  

## 동시 작업이 어려워진다.

한명은 web, 한명은 domain, 한명은 persistence 에 기능 추가.. 이렇게 하는게 맞을까?

계층형 아키텍처에서는 이렇게 작업할 수 밖에 없다. 계층형 아키텍처에서는 동시 작업을 지원하지 않는다. 모든 것이 persistence 위에서 만들어지기 때문에 persistence → domain → web 순서로 만들어진다. 때문에 동시에 한 명의 개발자만 작업이 가능하다.

개발자들이 인터페이스를 먼저 정의하고 기다릴 필요없이 작업할 수도 있다. 그러나 이 역시도 DB 주도 설계를 하지 않은 경우에만 가능하다. 그러나 계층형 아키텍처는 DB 주도 설계를 유도한다.

코드에 넓은 컴포넌트가 있다면 동시 작업이 더욱 어렵다. 형상관리에서 merge conflict 가 발생할 가능성이 매우 높다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러가도록 용인한다. 아주 엄격한 자기 훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하 기가 어려워지기 쉽다. 그리고 이러한 자기 훈련은 보통 프로젝트 매니저가 개발팀에 새 로운 마감일을 설정할 때마다 조금씩 느슨해지기 마련이다.

계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이 될 것이다.