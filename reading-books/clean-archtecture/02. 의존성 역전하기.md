SRP(Single Responsibility Principle) 과 DIP(Dependency Inversion Principle) 가 중심이다.

## 단일 책임 원칙

> 하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야 한다.

좋은 이야기지만 실제 의도는 아니다. 책임이라는 표현은 ‘한 가지 일만 잘하는 것’ 보다 ‘변경할 이유’로 해석해야 한다. 그럼 아래와 같이 변경된다.

> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

컴포넌트를 변경할 이유가 한 가지라면, 우리가 다른 이유로 소프트웨어를 변경하더라도 그 컴포넌트에 대해서는 걱정할 필요가 없다. 기대한 대로 동작할 것이기 때문이다.

![](https://i.imgur.com/Um8RZKA.png)

변경할 이유는 의존을 통해 쉽게 전파된다. E 는 아무것도 의존하지 않기 때문에 나머지 컴포넌트들의 변경으로부터 자유롭지만, A 는 모든 컴포넌트의 변화에 영향을 받는다.

많은 코드들은 SRP 를 위반하기 때문에 시간이 갈수록 변경하기 어렵다. 변경할 이유가 많아진 후엔 컴포넌트를 변경하는 것이 다른 컴포넌트가 실패하는 원인이 될 수 있다. 더 이상 리팩터링이 아니라 신규 개발을 진행하게 될지도 모른다.

## 부수효과에 관한 이야기

컴포넌트간 의존, 변경할 이유 전파를 제대로 관리하지 못하고 계속해서 변화에 영향을 받을 경우 클라이언트가 이를 학습하고 부정적인 의견을 내비출 수도 있다.

> 클라이언트는 나의 제안을 거절했고, 더 이상하고 비용이 많이 드는 방식을 주문했다. 그 이유를 들어보니 이전 개발팀에서 과거에 그 컴포넌트를 변경했을 때 언제나 다른 무언가가 망가졌기 때문에 변경에 대한 사이드이펙트를 우려했던 것이다.

## 의존성 역전 원칙

계층형 아키텍처에서 계층 간 의존성은 항상 하위 계층을 가리킨다. SRP 를 고수준에서 적용하기 위해선 항상 상위 계층이 하위 계층보다 변경할 이유가 더 많아진다. 즉, persistence 계층을 변경할 때마다 domain, web 계층도 영향을 받는다. 그러나 domain 은 애플리케이션에서 가장 중요한 계층이다. persistence 의 변경에 domain 이 계속 흔들려야할까?

DIP 가 그 답을 알려준다. 의존성 역전을 통해 책임(변경할 이유)을 줄일 수 있다.

> 코드상 어떤 의존성이든 그 방향을 역전시킬 수 있다.

엔티티는 domain 객체를 표현하고, domain 코드는 이 엔티티들의 상태를 변경하는 일을 한다. 때문에 우선 persistence 계층에 있던 엔티티를 domain 으로 옮긴다.

이렇게 하면 persistence 계층의 repository 와 domain 계층간 순환 의존성이 생긴다. 이 부분이 바로 DIP 를 적용하는 부분이다. domain 계층에 repository interface 를 만들고, 실제 repository 는 persistence 계층에서 구현하는 것이다.

![](https://i.imgur.com/48Y3oMX.png)

## 클린 아키텍처

클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트를 쉽게 만들고, 비즈니스 규칙은 프레임워크나 DB, UI, 그 밖 외부 App 이나 인터페이스로부터 독립적일 수 있다. 이는 반대로 말하면 domain 코드가 바깥으로 향하는 의존성이 아예 없어야 함을 의미한다.

![](https://i.imgur.com/DNAevSp.png)

가장 중요한 규칙은 의존성 규칙이다. 계층간 모든 의존성은 안쪽으로 향해야 한다.

아키텍처의 코어 영역에는 `엔티티` 와 `유스케이스` 가 포함된다. 유스케이스(Service) 는 단일 책임을 갖기 위해 조금 더 세분화(좁은 서비스)돼 있다. 이를 통해 넓은 서비스 문제를 회피한다.

코어 주변으로 비즈니스 규칙을 지원하는 다른 컴포넌트들을 확인할 수 있다. ‘지원’ 이라 함은 영속성이나 UI 를 제공하는 것을 의미한다.

그 바깥 계층에서는 다른 서드파티 컴포넌트의 어댑터를 제공한다.

도메인 코드에서는 persistence, UI 에 관해 아무것도 모르기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고, 비즈니스 규칙에 집중할 수 있다. 그래서 DDD 를 가장 순수한 형태로 적용해볼 수도 있다.

물론 대가가 따른다. domain 이 persistence 나 controller 와 완전히 분리되기 때문에 모든 엔티티에 대한 모델을 각 게층에서 유지보수 해야한다. 가령 ORM 을 사용할 경우 domain 계층은 persistence 계층을 모르기 때문에 두 계층에서 각각 엔티티를 만들어야한다. 즉 두 엔티티를 서로 변환해가며 데이터를 주고 받아야 한다는 뜻. 다른 계층들도 마찬가지다.

하지만 이건 바람직한 현상이라고도 볼 수 있다. 특정 프레임워크나 계층에 특화된 문제로부터 온전히 자연스러운, 결합이 제거된 상태다. 가령 domain 엔티티는 JPA 가 필요로 하는 파라미터 없는 생성자가 없다.

클린 아키텍처는 다소 추상적이기 때문에 조금 더 깊게 들어가서 육각형 아키텍처를 살펴보자.

## 헥사고날 아키텍처
![](https://i.imgur.com/eeByx7S.png)

육각형 안에는 domain 엔티티와 유스케이스가 있다. 육각형에서 외부로 향하는 의존성이 아예 없고 모든 의존이 육각형을 향하기 때문에 클린 아키텍처에서 이야기하는 의존규칙이 그대로 적용된다.

육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터들이 있다. 입력 포트를 통해서는 코어를 호출하는 어댑터들이, 출력 포트를 통해서는 코어에 의해 호출되는 어댑터들이 있다. 입력포트와 출력포트는 모두 코어가 제공해야 한다.

입력포트는 어댑터들의 호출에 반응하기 위해 코어 유스케이스를 통해 구현해야한다. 출력포트는 코어의 호출에 반응하기 위해 어댑터를 통해 구현해야한다.

이러한 핵심 개념으로 인해 헥사고날 아키텍처는 ports-and-adapters 아키텍처로도 알려져있다. 클린 아키텍처처럼 육각형 아키텍처도 계층으로 구성할 수 있다. 가장 바깥쪽에 있는 계층은 애플리케이션과 다른 시스템 간의 번역을 담당하는 어댑터로 구성돼 있다. (web, persistence) 포트와 유스케이스 구현체를 결합해서 application 계층을 구성할 수 있는데, 이 두 가지가 애플리케이션의 인터페이스를 정의하기 때문이다. 마지막 계층에는 domain 엔티티가 위치한다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

결국 의존성을 역전시켜 domain 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 domain 로직의 결합을 제거하고 코드를 변경할 이유(책임) 수를 줄일 수 있다. 그리고 책임이 적을수록 유지보수성은 더 좋아진다.

도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 변경될 수 있고, persistence, web 코드도 각각의 문제에 맞게 변경될 수 있다.
