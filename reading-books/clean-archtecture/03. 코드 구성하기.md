코드를 보는 것만으로도 아키텍처를 파악할 수 있다면 좋지 않을까?

새 프로젝트에서 가장 먼저 제대로 만들려고 하는 것은 패키지 구조다. 프로젝트에서 계속 사용할 괜찮아 보이는 구조를 잡는다. 그러고 나서 프로젝트가 진행될수록 점점 바빠지고 패키지 구조는 짜임새 없는 엉망진창 코드를 그럴싸하게 보이게 만드는 껍데기일 뿐이라는 점을 깨닫게 된다. 한 패키지에 있는 클래스들이 불러오지(import) 말아야 할 다른 패키지에 있는 클래스들을 불러오게 된다.

## 계층으로 구성하기

![](https://i.imgur.com/tgDFLkj.png)

이 패키지 구조는 3가지 이유로 최적의 구조가 아니다.

1. 애플리케이션의 기능이나 특성을 구분 짓는 경계가 없다. 이 구조에서 사용자를 관리하는 기능을 추가하려면 `web.UserController`, `persistence.UserRepositoryImpl`, `domain.User` 등을 추가할 것이다. 일정에 쫒기기 시작하면 서로 연관되지 않은 기능들끼리 뒤섞여 의존하기 시작하고 사이드이펙트를 만드는 엉망진창 묶음이 된다.
2. 애플리케이션이 어떤 유스케이스를 제공하는지 파악할 수 없다. `AccountService` 와 `AccountController` 가 제공하는 유스케이스에 대해 상세하게 추측이 가능한가? 특정 기능을 찾기 위해 클래스 명칭을 단서삼아 “추측”을 해야하는 상태다.
3. 패키지 구조를 통해 우리가 헥사고날 아키텍처를 구현하고자 함이 드러나지 않는다. 어디에 어떤 코드가 있는지 모르고, 인커밍 포트나 아웃고잉 포트가 코드 속에 숨어있는 등 문제가 있다.

## 기능으로 구성하기

![](https://i.imgur.com/rregun2.png)

계좌와 관련된 모든 코드를 최상위 `account` 패키지에 넣었다.

각 기능을 묶은 새로운 그룹은 `account` 와 같은 레벨의 새로운 패캐지로 이동하고, 패키지 외부에서 접근하면 안되는 클래스들에 대해 package-private 접근 제한을 이용할 수 있다. 이를 통해 불필요한 의존 방어도 가능하다.

또한 `AccountService` 의 너무 넓은 책임을 좁히기 위해 `SendMoneyService` 로 명칭을 바꿨다. 이제 클래스 명칭만으로도 ‘송금하기’ 유스케이스를 찾을 수 있다. (로버트 마틴의 ‘소리치는 아키텍처’가 완성된다. “니가 고칠 코드 여기에 있어!”)

그러나 아키텍처 가시성이 떨어진다. 어댑터와 코어의 구분이 없고, 포트도 확인할 수 없다. 심지어 DIP 를 통해 코어 계층이 persistence 계층을 모르게 했음에도 실수로 의존하는 걸 막을 수 없다.

## 아키텍처적으로 표현력 있는 패키지 구조

![](https://i.imgur.com/UxhjLuf.png)

- 최상위에는 `Account` 와 관련있는 유스케이스를 구현한 모듈임을 나타내는 `account` 가 있다.
- `domain`, `application`, `adpater` 로 코어 계층과 외부 계층을 분리한다.
    - 코어: `domain`, `application`
    - 외부: `adpater`
- `SendMoneyService` 는 인커밍 포트 인터페이스인 `SendMoneyUseCase` 를 구현한다.
- 아웃고잉 포트에 `LoadAccountPort` 와 `updateAccountStatePort` 인터페이스를 둔다.
- `adapter` 패키지는 application 계층의 인커밍 포트를 호출하는 어댑터와, application 계층의 아웃고잉 포트를 구현하는 어댑터를 둔다.
    - 각각 하위 패키지로 web, persistence 임을 나타낸다.

패키지 구조를 처음 접한다면 다소 헷갈릴 수 있으나, 익숙해진다면 이내 객체지향 프로그래밍처럼 직관적인 구조라는 걸 알게 된다. 현재 사용 중인 서드파티 API 에 대한 클라이언트를 변경하는 작업에 대해 동료와 이야기를 나눈다고 상상해보자. 그 과정에서 서로간의 이해를 돕기 위해 그 부분에 해당 하는 아웃고잉 어댑터를 그림에서 가리킬 수 있다. 그러고 나서 이야기를 끝냈을 때, IDE 앞에 앉아서 클라이언트를 변경하는 작업을 바로 시작할 수 있다. 해당 API 클라이언트 의 코드는 `adapter/out/<어댑터 이름>` 패키지에서 곧바로 찾을 수 있기 때문이다.

이른바 아키텍처와 코드간 갭, 모델과 코드간 갭을 다룰 수 있는 강력한 구조다. 또한 표현력 있는 패키지 구조는 자동적으로 아키텍처에 대한 사고를 적극적이게 만든다. 현재 작업중인 코드를 어떤 패키지에 넣어야할지 계속 고민하게 만들기 때문이다.

조금의 문제가 된다면 패키지 구조로 인해 public 접근제한자가 많아진다는 점이 있는데, 적어도 adapter 패키지는 안전하다. application 패키지 내부 포트 인터페이스를 통하는게 아니라면 호출되지 않기 때문이다. 다만 application, domain 패키지 일부 클래스들은 public 이 되어야 한다.

어댑터 코드를 자체 패키지로 이동시키면 필요할 경우 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다는 장점도 있다. 예를 들어, 최종적으로 어떤 데이터베이스가 적절 할지 확실하지 않아서 간단한 KEY-VALUE 데이터베이스로 개발을 시작했는데, SQL 데이터 베이스로 교체해야 한다고 가정해보자. 간단하게 관련 아웃고잉 포트들만 새로운 어댑터 패키지에 구현하고 기존 패키지를 지우면 된다.

또한 DDD 개념에 직접 대응이 가능하다. `account` 같은 상위 레벨 패키지는 다른 바운디드 컨텍스트와 통신할 전용 인커밍, 아웃고잉 포트를 제공하고 있다. `domain` 패키지 내부는 DDD 의 모든 것을 적용할 수 있다.

모든 구조와 마찬가지로 패키지 구조를 지키기 위한 규칙들이 있다. 혹은 적합하지 않아서 패키지를 바꿔야할 수도 있다. 정답은 없다.

## 의존성 주입의 역할

![](https://i.imgur.com/Z8ZTEXT.png)

가장 본질적인 요건은 application 게층이 외부 어댑터의 의존성을 갖지 않는 것이다.

인커밍 어댑터에 대해서는 의존성을 갖지 않게 하기 쉽다. 제어의 흐름 방향이 계층간 의존 방향과 같기 때문이다. 그러나 아웃고잉 어댑터에 대해서는 제어 흐름의 반대 방향으로 의존성을 돌리기 위해 DIP 를 사용해야 한다.

그런데 DIP 로 구현한 실제 객체를 누가 application 계층에 제공할까? 이 부분에서는 의존성 주입을 해결해주는 중립적인 컴포넌트를 하나 도입하면 된다. (Spring 이 알아서 해주는 것. Spring Bean Container)

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

코드에서 아키텍처의 특정 요소를 찾으려면 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다. 이로써 의사소통, 개발, 유지보수가 모두 조금 더 수월해졌다.