## 1장

> 코드를 읽을 일이 많아진다는 것은 곧 가독성을 높여야 생산성을 개선한다는 뜻입니다.

코드를 작성하는 것도 결국 글을 쓰는 것과 마찬가지. “독자가 어떻게 읽을까?” 고민하는 것처럼 “동료 개발자가 어떻게 읽을까?” 를 항상 고민해야한다. 이걸 계속 상기한다면 어떤 코드를 어디에 작성할지, 어떤 클래스 파일을 어디에 배치할지 고민하는 시간이 짧아진다..!

> 개발의 규모가 커질수록 코드를 이해하는 데 걸리는 시간이 비례하여 늘어나며, 작업 시간을 줄이려면 코드의 가독성이 높아야 합니다.

또한 한 사람이 인지해야하는(봐야하는) 코드의 양을 줄이는 노력도 필요하다. 이럴 때 고민하기 시작하는 것이 Bounded Context 라고 생각함. 인간 뇌의 한계(인지 능력의 한계)를 인정하고 꼭 열어봐야할, 인지해야할 범위를 제한하는 것.

코드를 작성하는 순간 뿐만 아니라 GitHub 에 PR 을 올릴 때도 가능하면 적은 파일 개수, 적은 라인 수를 만들어 올리는 것이 중요하다. 코드 리뷰시 집중도가 다름.

> 거의 읽히지 않는 코드라면 가독성은 크게 중요하지 않습니다.

유시보수 할 일이 거의 없는 엄한 코드에 공을 들이다가 시간을 뺏기지 않도록 주의하자…

> 리팩터링을 전제로 임시 코드를 작성할 수도 있습니다. 하지만 해당 기능의 개발이 순조롭게 마무리된 이후에도 또 다른 ‘중요한’ 기능개발이 연이어 요구되어 리팩터링할 여유가 없는 환경이라면 어떨까요?

사실상 대부분의 회사에서 그렇지 않나… 작업속도, 처리량도 중요하지만 높은 수준의 코드 퀄리티를 유지할 수 있도록 장려하는 분위기, 환경도 중요하게 느껴진다. 개인의 평가 방식이 작업속도에만 맞춰지면 아래와 같은 우스꽝스러운 상황이 연출된다고 한다.

> Bob은 가독성을 신경 쓰지 않고 임시 코드로 개발하기 때문에 높은 개발 속도를 유지할 수 있지만, 이때 Alice는 Bob이 작성한 코드를 리팩터링하면서 기능 개발을 병행하므로 개발 효율이 현저히 떨어지게 됩니다. 게다가 Bob 은 Alice 가 리팩터링한 코드를 바탕으로 또 다시 임시 코드로 개발하므로…

흠 ㅋㅋㅋㅋ 분명히 겪어본… ㅋㅋㅋㅋ…

> 전체 생산성에 미치는 기여도를 고려한 제도가 마련되어야 합니다. 하지만 이는 결코 쉽지 않은 일이며…

결국 ‘전체 생산성 기여도’ 를 평가하려면, 모든 팀원이 나쁜 코드 퀄리티로 인해 생산성이 떨어진다는 경험을 하고, 공감하고 있어야한다고 생각한다. 백엔드 팀은 이것을 경험했는가? 이것에 공감하고 있는가?

> 단순한 코드 isA && isB 와 !(!isA || !isB) && isB

사실 “isNotA 같은 질의 메서드 만들어서 ! 제거하는거 어떨까요?” 이런 코멘트 자주 남겼는데, 잘 받아들여지지 않은 것 같음. 귀찮을 수 있겠지만 사소한 배려가 많은 팀원들의 생산성에 도움이 된다는게 강하게 전달되면 좋겠다!

> 코드의 책임 범위를 명확히 한다. 다른 집합과의 의존 관계를 제한한다. 

“지금 코드를 작성할 때 이런 느낌으로 배치하면 되겠지.” 는 코드를 작성하는 당사자에게만 도움이 되는 책임 범위.

“나중에 이런 사유로 이 부분을 고칠텐데, 꼭 분리를 하기보단 조금 길어도 하나의 클래스 파일에 모아둘까? 그럼 이것만 열어보면 유지보수가 끝날텐데?” 가 제대로 된 책임 범위를 고민한게 아닐까?

프로젝트들 중 enum class 끼리 모아두고, repository 끼리 모아두고… 이런 계층 기반 클래스 파일 배치가 굉장히 많은데  유지보수할 땐 너무 넓은 범위의 패키지 트리를 오고 가야해서 헷갈린다. 유지보수 할 도메인에 맞춰서 패키지를 나누고, 그곳에 몰아두는 건 어떨까?

> 검증의 자동화

테스트 방식이 너무 복잡하고 귀찮아서 배포 후 수동으로 테스트 해야하는 것들이 존재한다. 급한 일정 속에서는 어쩔 수 없지만, 정말 테스트 하고 싶은 기능이 무엇인지 명확하게 인지하고 테스트 코드를 작성하다보면 자연스럽게 좋은 설계, 좋은 아키텍처에 대한 고민까지도 확장될 것 같다.

> fun queryPage(parameters: Map<String, String>
> 
> fun queryPage(pageIndex: Int, isAscendingOrder: Boolean)

전자는 내가 제일 싫어하는 코드. 어떤 쿼리를 던질 수 있는지 로그를 찍어보지 않으면 아무것도 알 수 없다. 저걸 찾아내는데 불필요한 시간을 소모해야한다. 저렇게 만들어두면 “매번 새로운 메서드를 만들 필요 없이 무한한 재활용이 가능하다.” 고 하는데… 그렇게 재활용을 몇번이나 더 할것인지? 그냥 매번 후자같은 새로운 메서드 몇 개 더 만들면 안되나?!

> 보이스카우트 원칙: 거대한 분기 코드에 조건 분기를 하나 덧붙이지말고 리팩터링한다.

글쎄… 조건 분기문에 대해서는 인정하나, 그 외 경우는 잘 모르겠다. 빠르고 간결하게 리팩터링 할 수 있으면 좋겠지만 경험상 전체 리팩터링보단 덧붙이는 코드 5줄 추가하는게 작업자도 편하고 리뷰하는 사람도 반응이 좋았다. (리팩터링하면 읽어야 할 코드 라인수가 갑자기 확 늘어서 읽지 않음. 조건이 하나 추가될 땐 비즈니스 정책까지 모두 확인해줌)

물론 이 과정이 수차례 반복되면 건드리기 어려운 빅보이가 되는 것 같다. 아, 개발 너무 어렵다 :expressionless:

> KISS: 적은 규칙으로 모델을 구축하거나, 일관된 라이브러리나 프레임워크로 모든 요소를 표현하는 것이 기술적으로 우아하다고 느끼는 사람들도 적지 않습니다. ‘자신이 작성하기 편한 코드’가 아닌 ‘다른 사람이 읽기 편한 코드인가’에 주목해야합니다.

동의 동의 또 동의

> SRP: 클래스의 책임을 명확하고 작게 유지한다.

다만 이건 코드 배치를 이쁘게 나누자! 가 되어선 절대 안되겠고, 비즈니스에 대한 이해도가 높아서 “이 요구사항에는 이런걸 보겠지” 라는 기준으로 책임을 나눠야한다고 생각

<br> 

## 2장

> 심미성, 통일성, 일관성은 가독성을 위한 수단일 뿐. 그 자체가 목적이 되면 안 됩니다.

> 적절한 이름: 대상이 무엇인지, 무엇을 하는지를 나타내는 이름
> 
> 부적절한 이름: 언제, 어디서, 어떻게 사용되는지를 나타내는 이름
 
이거 아주 중요하다고 생각. 특히 이벤트처리하는 핸들러에 이런 실수 많이 하는 것 같음. 

- 후자의 네이밍을 사용하면 내부에서 어떤 일이 일어나는지 내부 코드를 모두 읽어봐야한다.
- 또한 후자의 네이밍을 사용하면 “언제”, “어디서” 가 변경되면 그것에 바로 영향을 받는다.
- 같은 동작을 요구하는 호출자가 메서드를 재활용하지 못하고 하나 또 만들어야한다는 문제점은 덤

예외로 콜백 메서드는 “언제”, “어디서” 를 이용할 수 밖에 없다.
